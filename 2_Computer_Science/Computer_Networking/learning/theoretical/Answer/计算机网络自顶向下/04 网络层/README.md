#### 网络层

* 本章有 3 个主要部分:
	* 涉及网络层功能和服务 (4.1 ~ 4.2)
	* 转发 (4.3 ~ 4.4)
	* 路由选择 (4.5 ~ 4.7)
	
* 4.1 **概述**

	* 4.1.1 **转发和路由选择**
	
		* 网络层的作用 : 将分组从一台发送主机移动到一台接受主机，为此，网络层需要具有两项功能。
		
			* **转发** : 路由器将到达它某条输入链路的分组移动到适当的输出链路，时间尺度很短为纳秒级，通常用硬件实现。
		
			* **路由选择** : 在路由器图结构中决定分组从源端到目的端的路径的算法，时间长度通常为几秒，通常用软件实现。
			
			* ![](https://github.com/YangXiaoHei/Networking/blob/master/计算机网络自顶向下/04%20网络层/images/network_layer_outline.png)
	
	* 4.1.2 **网络层服务模型**
	
		* 网络层服务模型决定了分组的端到端运输特性，下列是网络层可能提供的服务：
		
			* **确保交付**：该服务确保分组最终到达目的地。
			
			* **具有时延上界的确保交付**
			
			* **有序分组交付**
			
			* **确保最小带宽**：模拟在发送方和接收方之间一条特定比特率的传输链路行为。只要发送主机以低于特定比特率的速率传输比特，则分组不会丢失，且每个分组会在预定的端到端时延内到达。
			
			* **确保最大时延抖动**：确保目的方接收两个相继分组的时间间隔等于发送方发送这两个相继分组的时间间隔，或者该间隔不超过某个特定值。
			
			* **安全性服务**：网络层能够在源加密所有数据报并在目的地解密这些分组，从而对所有运输层报文段提供机密性。
		
		* 因特网、`ATM CBR` 和 `ATM ABR` 服务模型
		
	 	| 网络体系结构|服务模型|带宽保证|无丢包保证|有序|定时|拥塞指示|
    	| :--------:|:-----:|:----:|:----:|:----:|:----:|:----:|
    	| 因特网	| 尽力而为	|  无    | 无 |  任何可能顺序 | 不维护| 无 |
    	| ATM		| 恒定比特率| 保证恒定速率 | 是 | 有序 | 维护 | 不出现拥塞 |
    	| ATM 	| 可用比特率| 保证最小速率 | 无 | 有序 | 不维护 | 提供拥塞指示 |
   
   
  * 4.2 **虚电路和数据报网络**
 
  	 * ⚠️ **运输层的连接服务仅在端系统中实现，而网络层的连接服务既在端系统中实现，也在路由器中实现。**
  		
  	 * 4.2.1 **虚电路网络**: 网络层提供连接服务的计算机网络
  	 	 * 虚电路组成如下：
  	 	  	 * 1、源和目的主机之间的路径 (一系列路由器和链路)
  	 	  	 * 2、VC 号，沿着该路径的每段链路的一个号码
  	 	  	 * 3、沿着该路径的每台路由器中的转发表表项
  	 	 * 属于一条虚电路的分组会在首部携带一个 VC 号。一条虚电路在每条链路上可能具有不同的 VC 号，每台中间路由器必须用一个新的 VC 号替代每个传输分组的 VC 号。该新的 VC 号从转发表获得，下面的表格是路由器中包含 VC 号的转发表。
  	 	 
	  	 * | 入接口号 |入 VC 号|出接口号|出 VC 号|
	  	 	|:---:|:---:|:---:|:---:|
	  	 	| 1 | 12 |2 |22 |
	  	 	|2|63|1|18|
	  	 	|3|7|2|17|
	  	 	|4|97|3|87|
	  	 	|...|...|...|...|
  	 	 
  	 	 * ![](https://github.com/YangXiaoHei/Networking/blob/master/计算机网络自顶向下/04%20网络层/images/VC_number.png)

  	 	 * **虚电路建立**: 网络层决定发送方与接收方之间的路径，并为该路径的每条链路决定一个 VC 号，最后在沿着该路径的每台路由器转发表中增加一个表项，并预留该虚电路路径上的资源比如带宽。
  	 	 
  	 	 * **数据传送**: 分组沿着该虚电路流动

  	 	 * **虚电路拆除**: 发送方或接收方通知网络层终止该虚电路时，网络层将通知网络另一侧的端系统结束呼叫，然后删除该路径上每台路由器中的转发表的相应表项，以此表明该虚电路已经不存在。
  	 	 
  	 * 4.2.2 **数据报网络**: 网络层不提供连接服务的计算机网络
		 * 路由器使用分组的目的地址的 **前缀** 进行 **最长前缀匹配** 来决定将该分组导向哪条输出链路。

		 * 数据报网络中的转发表是通过路由选择算法修改的 (**AS** 间和 **AS** 内部)。
		 
		 * 因为数据报网络中的转发表能够在任何时刻修改，从一个端系统到另一个端系统发送的分组可能在通过网络时走不同的路径，并可能无序到达。

  * 4.3 **路由器工作原理**
  	
  	* ![](https://github.com/YangXiaoHei/Networking/blob/master/计算机网络自顶向下/04%20网络层/images/Router_structure.png)
	
	* 路由器的主要作用是将数据包从入链路转发到出链路，除了控制目的外的路由器不运行应用层和运输层协议。
	
	* ⚠️**不能理解为路由器没有实现运输层或应用层协议，比如:** **AS** 内部路由选择协议 **RIP** 就使用运输层协议 **UDP** 在端口 520 上发送 **RIP** 通告来更新路由表的配置。**AS** 内部路由选择协议 **OSPF** 的报文也承载在 **IP** 数据报中，它需要自己实现可靠传输机制。**AS** 间路由选择协议 **BGP4** 则更是通过路由器之间的 **TCP** 连接发送 **BGP** 通告来更新路由表配置。 
	
	* **分组交换机**
		
		* **链路层交换机**：基于链路层字段作转发决定

		* **路由器**：基于网络层字段作转发决定
  	
  	* 4.3.1 **输入端口**
  		* **物理层和链路层处理**
  		* **检查分组版本号，检查并重写校验和以及寿命字段**
  		* **更新用于网络管理的计数器（比如接受到的 IP 数据报的数目）**
  		* **搜索转发表查找最长前缀匹配，决定分组的输出链路**
  	
  	* 4.3.2 **交换结构**
  		* ![](https://github.com/YangXiaoHei/Networking/blob/master/计算机网络自顶向下/04%20网络层/images/Switching_3_structure.png)
  		* **经内存交换**
  			* **输入端口与输出端口之间的交换是在 CPU (路由选择处理器) 的直接控制下完成的，如果内存带宽为每秒可写进内存或从内存读出 B 个分组，则总的转发吞吐量 (分组从输入端口被传送到输出端口的总速率) 必然小于 B/2，并且不能同时转发两个分组，即便它们有不同的端口号，因为经过共享系统总线一次仅能执行一个内存读/写**
  			
  			* 1、分组到达输入端口

  			* 2、通过中断方式向路由选择处理器发出信号
  			
  			* 3、分组从输入端口处被复制到处理器内存中
  			
  			* 4、路由选择处理器从首部中提取目的地址，查找转发表并匹配最长前缀，决定适当的输出端口
  			
  			* 5、路由选择处理器将该分组复制到输出端口缓存中。

  		* **经总线交换**
			* **不需要路由选择处理器干预，输入端口经一根共享总线将分组直接传送到输出端口，由于一次只能有一个分组能够跨越总线，因此总的转发吞吐量受总线传播分组速率的限制**
			
			* 1、输入端口为分组预先设置一个交换剂内部标签 (首部), 指示本地输出端口
			
			* 2、分组由总线传送到输出端口

			* 3、所有端口都能收到该分组，但只有内部标签匹配的端口才能保存该分组。
			* 4、输出端口处去掉该分组的内部标签
			
  		* **经互联网络交换**
  			* **能够并行转发多个分组，但如果来自两个不同输入端口的分组其目的地为相同的输出端口，则其中一个分组必须在输入端等待，因为在每个时刻经给定总线仅有一个分组能够发送**
		
  	* 4.3.4 何处出现排队
  		* 输入端口
  			* 若 `Rswitch` 比 `Rline` 快 N 倍，那么即便分组是突然性到达，每个分组也仅会经受微不足道的时延，并且每批分组能在下一批到达前被交换结构处理完毕，但是，若交换结构不能快得让所有到达分组都无时延通过它传送，则在输入端口处也会排队
  			
		   * 另一种排队是因为 **线路前部阻塞**，这是因为输入队列中排在后面的分组，必须等待前面的分组被交换结构处理完毕，即使排在后面的分组要去往的输出端口是空闲的，入下图所示。
		   
		   * ![](https://github.com/YangXiaoHei/Networking/blob/master/计算机网络自顶向下/04%20网络层/images/HOL.png)
  			
  		* 输出端口
  			* 若 `Rswitch` 比 `Rline` 快 N 倍，那么最坏情况下，若所有到达输入端口的分组都要去到同一个输出端口，则在输出端口发送完 1 个分组的时间内，就到达了 N 个分组，再发送完一个分组，又到达 N 个分组，这将导致输出端口可用内存被很快耗尽，最终产生大量丢包。

  			* 输出端口上的 **分组调度程序** 必须在排队的分组中选出一个来发送，策略有 **先到先服务 (FCFS)**，或者 **加权公平排队（WFQ）**
  		
  		* 路由器缓存长度经验公式
  			* `缓存数量 B = 平均往返时延 RTT x 链路容量 C`
  			* `缓存数量 B = RTT * C/sqrt(N)`
			
	* 4.3.5 分组调度
	  * 以下描述输出链路中排队分组如何被调度并传输的问题。
	    * 1. 先进先出
	      * ![](https://github.com/YangXiaoHei/Networking/blob/master/计算机网络自顶向下/04%20网络层/images/FIFO_scheduling.png)
	    * 2. 优先权排队
	      * ![](https://github.com/YangXiaoHei/Networking/blob/master/计算机网络自顶向下/04%20网络层/images/priority_scheduling.png)
	    * 3. 循环和加权公平排队
	      * ![](https://github.com/YangXiaoHei/Networking/blob/master/计算机网络自顶向下/04%20网络层/images/loop_weighted_scheduling.png)

  * 4.4 **网际协议：因特网中的转发和编址**
  
  	 * **4.4.1 数据报格式**
  	 
  	 	 * ![](https://github.com/YangXiaoHei/Networking/blob/master/计算机网络自顶向下/04%20网络层/images/IPv4报文格式.png)
		
		 * IP 数据报分片
		 	* 并不是所有链路层协议都能承载相同长度的网络层分组。有的协议能承载大数据报，有的只能承载小数据报。例如，以太网帧能承载不超过 1500 字节的数据，而某些广域网链路的帧可承载不超过 576 字节的数据。一个链路层帧能承载的最大数据量叫做 **最大传送单元 MTU**，每个 IP 数据报封装在链路层帧中从一台路由器传输到下一台路由器，所以链路层帧的 MTU 严格限制着 IP 数据报的长度。并且发送方到接收方路径上的每段链路可能使用不同的链路层协议，每种协议可能有不同的 MTU。
		 	
		 	* ⚠️ 路由器中可能会执行 IP 数据报的分片操作，当下一段链路的 MTU 小于路由器接收到的 IP 数据报长度时。但是数据报的组装工作只在端系统的网络层进行，而不会在路由器的网络层进行。如果一个或多个片没有到达目的地，则该不完整的数据报会被接收方的网络层丢弃。
		 	
		 	* ![](https://github.com/YangXiaoHei/Networking/blob/master/计算机网络自顶向下/04%20网络层/images/分片和组装.png)

		 	* 可以通过设置片的偏移量从而使数据报无法恰当的重建来攻击，IPv6 禁止分片，从而简化了 IP 分组的处理，并使得 IP 不太容易收到攻击。
		 	
	* **4.4.2 IPv4 编址**
		*  IP 地址是与每一个接口相关联，而不是与包括该接口的主机或路由器相关联的
		
		*  因特网的地址分配策略是 ：CIDR，对于子网寻址，32 比特的 IP 地址被划分为两部分，并具有 a.b.c.d/x 的点分十进制形式。x 数目的最高比特构成了网络前缀。
		
		*  **主机或子网如何获取 IP 地址** 
		
			* **1、获取一块地址**
				* ICANN 给 **ISP** 分配可用 IP 地址范围，**ISP** 给内部子网分配可用 IP 地址范围
			
			* **2、获取主机地址 : DHCP 动态主机配置协议**
			
				* DHCP 允许主机自动获取一个 IP 地址，网络管理员能够配置 DHCP 使得主机每次与网络连接能否获得一个相同 IP 地址，或者某主机将被分配一个临时的 IP 地址，除了获得 IP 地址，DHCP 还允许一台主机得知其他信息，比如：子网掩码、第一跳路由器地址，本地 **DNS** 服务器地址。
				
				* 通过 **DHCP** 获取 IP 地址的步骤如下图所示
				
				  ![](https://github.com/YangXiaoHei/Networking/blob/master/计算机网络自顶向下/04%20网络层/images/DHCP_interaction.png)
				  
			   * 在不同的 Wifi 间切换实际上发生的是不同 DHCP 服务器重新给你的主机分配 IP 地址的报文交换过程。
			   
			   * ![](https://github.com/YangXiaoHei/Networking/blob/master/计算机网络自顶向下/04%20网络层/images/DHCP_exchange_for_switching_wifi.png)
			   * ⚠️我注意到一个事实，那就是切换 Wifi 时，我们的主机是不会主动发送 DHCP release 报文的，这就意味着在你切换 Wifi 被 DHCP 服务器分配新的 IP 地址后，原先的 DHCP 服务器分配给你的 IP 地址仍然不能被他人使用，直到租期到期。
			   
			* **3、网络地址转换 NAT**
			
				* 具有 **NAT** 功能的路由器修改分组的 IP/Port 地址，使得子网内部的 IP 地址都可以自由分配，只需要在 **NAT** 表中完成到因特网 IP/Port 地址的映射关系即可。
				
				* 缺点 : 对 P2P 应用不友好，因为躲在 **NAT** 路由器背后的主机不能充当接入主动连接的服务器，此时需要 **NAT** 穿越。
				
			* **4、UPnP**
				
				* UPnP 允许外部主机使用 **TCP** 或 UDP 向 **NAT** 化的主机发起通信会话，UPnP 由于提供了有效和健壮的 **NAT** 穿越解决方案，可能成为 P2P 应用程序的救世主。
		
	* **4.4.3 因特网控制报文协议 ICMP**  
	
	* **4.4.4 IPv6** 
	
		* **1、IPv6 数据报格式**
		
		  * ![](https://github.com/YangXiaoHei/Networking/blob/master/计算机网络自顶向下/04%20网络层/images/IPv6_segment.png)
		  
		  * **IPv6 中删减 IPv4 中某些字段的意图:**
		  
		     * **分片/重新组装**
		     	 * IPv6 不允许在中间路由器上进行分片与重组，这种操作只能在源与目的地上进行。如果路由器收到的 IPv6 数据报因太大而不能转发到出链路的话，路由器会丢弃该数据报，并向发送方回一个 "分组太大" 的 ICMP 差错报文即可。
		     
		     * **首部校验和**
		        * 运输层和链路层都执行了校验操作，IP 设计者觉得该功能纯属多余，于是将其去除。毕竟，如果要计算校验和，由于每台路由器都修改 IP 数据报的 TTL，因此每台路由器都要重新计算校验和，将其去除无疑可以大大减轻一个耗时的操作。
		     
		     * **选项**
		        * IPv4 中的选项字段没有消失，而是出现在 IPv6 首部中由 "下一首部" 指出的位置上。TCP 和 UDP 首部能够是 IP 分组中的 "下一个首部"，选项字段也能是 "下一个首部"。删除选项字段使得 IP 首部成为定长 40 字节。
		
		* **2、从 IPv4 到 IPv6 的迁移**
		
	* **4.5 路由选择算法**
		
		* **4.5.1 链路状态路由选择算法**
			
			~~~
			对于出发结点 x
			初始化:
				1、对于每个目的结点 y, 计算 x -> y 的距离，若 y 不是 x 的邻居，那么距离为 ∞
				2、w = x
			
			循环直到 N' 队列容纳的元素个数等于 N
				1、找到当前访问结点 w 到所有邻居的最小距离 D(w)，将 w 添加进队列 N'，此时 N` 的元素个数加 1
				2、松弛 w 的所有邻边
			~~~
			
			* **振荡现象**
			
			 * ![](https://github.com/YangXiaoHei/Networking/blob/master/计算机网络自顶向下/04%20网络层/images/Oscillations.png)
			  
			 * **避免路由器自同步的方法** : 让每台路由器发送链路通告的时间随机化
			
		* **4.5.2 距离向量路由选择算法**
		
			~~~
			对于每个结点 x :
			初始化:
				1、对于每一个目的结点 y, 计算 x -> y 的距离，若 y 不是 x 的邻居，那么距离为 ∞
				2、对于 x 的每个邻居 w, 初始化每个 w -> y 的距离为 ∞
				3、对于 x 的每个邻居 w, x 将自己的距离向量 Dx 逐个发送给它们
				
			死循环
				等待下列事件触发，然后执行语句 [-]
						1、到达邻居 w 的链路费用发生改变
						2、收到来自邻居 w 的距离向量
						
				[-] 对于每一个目的结点 y，计算 x -> y 的距离
					 Dx(y) = MINv{ c(x, y) + Dv(y) }
				
				如果某个 Dx(y) 发生更新，那么对于 x 的每个邻居 w, 
				x 将自己的距离向量 Dx 逐个发送给它们
			~~~
			
			* 下列是一个距离向量算法从初始化到收敛的运行轨迹
			  * ![](https://github.com/YangXiaoHei/Networking/blob/master/计算机网络自顶向下/04%20网络层/images/DV_algorithms.png)
			
			* **1、链路费用增加与减少**
			  * 链路费用减少 (`4 -> 1`)
			     * ![](https://github.com/YangXiaoHei/Networking/blob/master/计算机网络自顶向下/04%20网络层/images/DV_algorithms_linkcost_decrease.png)
			     
			  * * 链路费用减少 (`50 -> 1`)
			     * ![](https://github.com/YangXiaoHei/Networking/blob/master/计算机网络自顶向下/04%20网络层/images/DV_algorithms_linkcost_decrease_2.png)
			
			  * 链路费用增加 (`4 -> 60`) 
			     * 引发无穷计数问题
		        * ![](https://github.com/YangXiaoHei/Networking/blob/master/计算机网络自顶向下/04%20网络层/images/DV_algorithms_linkcost_increase.png)
		     
		   * **2、增加毒性逆转**
		   
		   		* 如果 z 通过 y 路由选择到目的地 x，则 z 将通告 y，它 z 到 x 的距离是无穷大
		   		
		   		* 毒性逆转无法检测到涉及 3 个或更多结点的环路
		   		
		   * **3、LS 与 DV 路由选择算法的比较**
		     
  				* 距离向量算法中，每个结点仅与它的直接相连的邻居交谈，但它为其邻居提供了从它自己到网络中 (它所知道的) 所有其他结点的最低费用估计。
  
  				* 链路状态算法中，每个结点 (经广播) 与所有其他结点交谈，但它仅告诉它们与它直接相连链路的费用。
 
  				* **报文复杂性** 
  
     				* 链路状态算法要求每个结点都知道网络中每条链路的费用。这就要求发送 O(NE) 个报文 (从某个点点亮全图，需要 O(E) 报文，既然需要从每个点点亮全图，那就是 O(NE))，而且无论何时一条链路的费用发生变化，必须向所有结点发送新的链路费用。
     
     				* 距离向量算法中，仅当链路费用的改变引起该链路相邻结点之间的最路径发生变化时，才传播已改变费用的路径。
     
  				* **收敛速度** 
     			   * 链路状态算法需要发送 O(NE) 个报文，还需要执行 O(N^2) 以确定一条最短路径。
     
     			   * 距离向量算法收敛比较慢，而且收敛时会遇到路由选择环路，以及无穷计数的问题。
  
  				* **健壮性**
     			   * 链路状态算法计算转发表是在每台路由器上独立进行的，因此比较健壮。
     
     			   * 距离向量算法中，一个结点可向任意或所有目的结点通告不正确的最低费用路径。 

	* **4.5.3 层次路由选择**
		* 在 LS 和 DV 算法中，将网络只看作一个路由器的集合，由于下列两个原因，该模型是不切实际的：
		
			* **规模**  随着路由器数目更多，由广播 LS 更新所需要的开销将导致没有剩余的带宽用来发送数据分组，并且在众多的路由器间运行的 DV 算法将永远无法收敛。
			
			* **管理自洽**  某公司想要按照自己的意愿运行路由器，比如使用自己的路由选择算法，或者对外隐藏其网络的内部组织面貌。
			
		* 上述两个问题通过将路由器组织进 **自洽系统 AS** 来解决，一个 **AS** 是一组处于相同管理和技术控制下的路由器的集合，每个 **AS** 内部的所有路由器运行同样的路由选择算法，在一个 **AS** 内运行的路由选择算法叫做 **自洽系统内部路由选择协议**。**AS** 之间也需要互联，在 **AS** 内部的一台或多台路由器，负责向 **AS** 外部转发分组，这些路由器叫做 **网关路由器**。那么 **AS** 内部的路由器如何将分组路由选择到位于 **AS** 外部的目的地呢？**AS** 可能有一个或多个网关，如果只有一个网关，那么显然只需要将分组路由到唯一网关处，如果有多个网关，那么该 **AS** 需要:
			* 1、知道经过相邻的 **AS** 可达哪些目的地。
			* 2、向 **AS** 内部的所有路由器传播这些可达信息以便它们能配置自己的路由表。
	  * 【**从相邻 AS 获取哪些目的子网可达**】和 【**向该 AS 中所有路由器传播该可达信息**】这两项任务由 **自洽系统间路由选择协议** 处理。因特网中所有 **AS** 都运行相同的 **AS 间路由选择协议**，该协议称为 **BGP4**。每台路由器接受来自一个 **AS 内部路由选择协议** 和一个 **AS 间路由选择协议** 的信息来配置自己的转发表。
		
	   * ![](https://github.com/YangXiaoHei/Networking/blob/master/计算机网络自顶向下/04%20网络层/images/AS.png)
	   
	   * 下图总结了路由器对转发表增加一个表项所采取的动作
	   
	   	* ![](https://github.com/YangXiaoHei/Networking/blob/master/计算机网络自顶向下/04%20网络层/images/configure_AS_internal_forward_table.png) 
	   	
	   	* 某个 **AS** 从相邻 **AS** 处知道了一个目的地 (CDIR 化的前缀，而非主机 IP)，该 **AS** 能够向它相邻的 **AS** 继续通告该路由选择信息，一个 **AS** 决定向相邻 **AS** 通告哪些目的地具有很大的灵活性，这取决于经济问题而非技术。
	   	* **ISP** 与 **AS** 的关系 : 一个 **ISP** 内部可能划分为多个互联的 **AS**，或者一个 **ISP** 本身就是一个 **AS**。
		
	* **4.6 因特网中的路由选择**
	
		* 历史上有两个路由选择协议曾被广泛用于因疼上自洽系统内的路由选择 : **路由选择信息协议 RIP** 和 **开放最短路优选**。
	
		* **4.6.1 因特网中自洽系统内部的路由选择 : RIP**
			
			* **RIP** 是最早的 **AS** 内部因特网路由选择协议之一，且目前仍在广泛使用。**RIP** 是一种使用分布式，异步迭代的距离向量算法的协议，**RIP** 使用跳数作为链路的费用测量，一条路径的最大费用被限制为 15，因此 **RIP** 的使用限制在直径不超过 15 跳的 **AS** 内。每隔 30 秒，运行 **RIP** 的路由器向它的邻居发送 **RIP** 通告来更新彼此的距离向量。
			
			* 每个运行 **RIP** 的路由器维护一张路由选择表，该表由两部分组成 : 
				* **转发表** 
				* **距离向量** 
				
				* 下图是 **RIP** 通告工作的一个例子。
			
			*  ![](https://github.com/YangXiaoHei/Networking/blob/master/计算机网络自顶向下/04%20网络层/images/RIP_working.png)
			*
			* **RIP 注意点** :
			
				* **1、侦查到不可达现象** : 如果一台路由器超过 180 s 没有从邻居听到 **RIP** 通告，那么就认为该邻居不可达，当该情况发生时，**RIP** 修改本地路由选择表，然后向那些仍然可达的邻居发送通告来传播信息。

				* **2、主动查询费用** : 路由器也可以使用 **RIP** 请求报文来查询其邻居到指定目的地的费用。
				
				* **3、运行的协议栈** : 路由器在 UDP 上使用端口 520 相互发送 **RIP** 请求和响应报文。
		
		* **4.6.2 因特网中自洽系统内部的路由选择 : OSPF**
		
			* **OSPF** 通常被设置在上层的 **ISP** 中，而 **RIP** 却被设置在下层 **ISP** 和企业网络。
			
			* **OSPF** 的核心是一个使用洪泛链路状态信息的链路状态协议和一个 **Dijkstra** 算法。每台路由器都构建了一幅整个 **AS** 的完整拓扑图，于是它可以自己运行 **Dijkstra** 算法来确定以自己为根结点到所有子网的最短路径树。
			
			* **OSPF** 的路由器运行 **Dijkstra** 算法所依据的链路费用是网络管理员来配置的，他可以将所有链路费用设为 1，从而找出最少跳数。也可以设置为链路容量反比的函数从而鼓励使用高带宽链路。
			
			* 使用 **OSPF** 时，路由器向 **AS** 内所有其他路由器广播路由选择信息，而不仅仅是邻居。每当一条链路状态发生变化，比如费用改变，或者链接中断, 路由器就会广播信息。即使链路状态没有发生改变，它也会每隔 30 分钟广播一次。

		   * **OSPF** 报文直接由 IP 承载，对上层协议的值为 89，因此 **OSPF** 协议必须自己实现诸如可靠报文传输，链路状态广播等功能。
		
		* **4.6.3 自洽系统间的路由选择 : BGP**
		 * 1、**BGP 基础**
		 
		 	* **BGP** 中，一对路由器通过使用 179 端口的 **TCP** 连接来交换路由选择信息。在 **AS** 之间，**TCP** 连接位于两个网关路由器之间，在 **AS** 中，**TCP** 连接位于不同的内部路由器之间，这些 **TCP** 连接用于交换路由选择信息。
		 	
		 	* **BGP 对等方** : 位于 **BGP** **TCP** 连接两个端点的两台路由器称为 **BGP** 对等方
		 	* **BGP 会话** : 发送 **BGP** 报文来交换路由选择信息的 **BGP** **TCP** 连接被称为 **BGP** 会话。
		 	
		 	* **外部 BGP 会话** : 分别位于两个 **AS** 的两台路由器之间的 **BGP** 会话。比如 AS3 通过 eBGP 向 AS1 发送经 AS3 的可达前缀列表，AS1 也可向 AS3 发送经 AS1 的可达前缀列表。
		 	
		 	* **内部 BGP 会话** : 在同一个 **AS** 内的两台路由器之间的 **BGP** 会话。当从 eBGP 学习到前缀列表后，网关路由器通过 iBGP 向该 AS 中的其他路由器通告这些前缀。
		 	
		 	* ![](https://github.com/YangXiaoHei/Networking/blob/master/计算机网络自顶向下/04%20网络层/images/AS_BGP.png)

		 	* **新创公司如何获得因特网连通性 ?**
		 	
		 		* 1、与本地 **ISP** 签订合同之后， **ISP** 提供给你一个可用的 IP 地址范围，比如 172.32.1.0/24，该 **ISP** 通过 **AS** 间路由选择协议 **BGP4** 将此子网前缀通告给其他 **AS**。 
		 		
		 		* 2、并用一台网关路由器连接该本地 **ISP**，用 **ISP** 提供的一个范围内的 IP 地址给 Web 服务器，邮件服务器，**DNS** 服务器，网关路由器和公司网络中的其他网络设备分配 IP 地址。
		 		
		 		* 3、购买域名，域名卖主会将该域名的 A 记录 放入顶级域 **DNS** 服务器中，比如 .com 顶级域 **DNS** 服务器。
		 		
		 		* 4、在自己的 **DNS** 服务器中添加 Web 服务器的 A 记录，或者添加 CNAME 记录以便使得邮件服务器可供使用。
		 		
		 		* 5、由于 **AS** 之间的互相通告，因此其他 **AS** 中的路由器都知道如何抵达你公司的子网前缀所在的 **AS**，你的公司据此获得了因特网的连通性。
		 	
		 * 2、路径属性和 **BGP** 路由
		 	
		 	* **AS-PATH**
		 	
		 	* **NEXT-HOP**
		 	
		 * 3、**BGP** 路由选择
			
			* **BGP** 使用 eBGP 和 iBGP 向在 **AS** 中的所有路由器发布路由，因此，路由器可能知道达到任何一条前缀的多条路由，如何选择其中一条路由呢？
			
			    * 1、根据路由器被设置的偏好，由网络管理员决定。
			    
			    * 2、在具有相同偏好的路径中，选择具有最短 **AS-PATH** 的路由
			    
			    * 3、在具有同偏好和 **AS-PATH** 长度的路径中，选择最靠近 **NEXT-HOP** 路由器的路由，即在 **AS** 内部到达网关路由器最低费用路径的路由
			    
			    * 4、如果还有多条路由，该路由器使用 **BGP** 标识符来选择路由
			    
		 * 4、路由选择【策略】
		 	
		 	 * ![](https://github.com/YangXiaoHei/Networking/blob/master/计算机网络自顶向下/04%20网络层/images/BGP_routing_strategy.png)
		 	 
		 	 * 问题 1 : X 如何起到桩网络的作用 ？ 即 X 如何防止转发 B 与 C 之间的流量？
		 	 	  * X 向其他 **AS** 通告自己不会抵达任何 **AS** 即可，即便它自己知道有路可走。这样因为 B 知道 X 到不了 C，就不会期望通过 X 到达任何地方。
		 	 	
		 	 * 问题 2 : B 从 A 的通告得知了 AW 这条路径，它应该将之通告给 C 吗？
		 	 	  * 如果 B 告诉了 C，那么 C 想把分组发给 W ，就可能转而发给 B，让 B 承担流量费用，因此 B 多半不会选择告诉 C。

		 * 为什么会有不同的 **AS** 间和 **AS** 内部路由选择协议之分？
		 
		 	 *  策略 : **AS** 间路由想要流量不能穿越某个 **AS**，或者想要控制它承载的其他 **AS** 穿越的流量，那么策略是第一考虑要素，而在 **AS** 间策略微不足道。
		 	 	
		 	 *  规模 : 扩展性是 **AS** 间路由选择的关键问题，而 **AS** 内部路由选择没有规模的考虑，要是规模大了，那就分成两个 **AS** 呗。
		 	 	
		 	 *  性能 : **AS** 间以策略为主，性能是次要。**AS** 内部以性能为主，不关心策略。
	
	* **4.7 广播和多播路由选择**
	
		* **4.7.1 广播路由选择算法**
		   * **简单粗暴法**: N 次单播，由源结点发送 N 个目的分组
		      * 缺点 1: 在第一段链路上产生严重拥塞
		      * 缺点 2: 需要知道所有目的地的 IP 地址，这需要新的协议支持
		      * 缺点 3: 在用于计算转发表的路由信息时发送的报文数量达到 O(N^2)，是广播发送报文数量的最坏情况

	      * **无控制洪泛**
	         * 源结点向每个邻居发送分组副本，每个收到分组的结点向所有邻居继续发送分组的副本。
	         * 缺点 1: 如果图有环，则一个或多个分组将无休止的循环。
	         * 缺点 2: 广播风暴
	         
	      * **受控洪泛**
	         * **序号控制洪泛**：源结点将其地址或唯一标识符和广播序号放入分组，再向它的所有邻居发送该分组。每个结点维护它收到、转发的每个分组的源地址和序号列表，如果收到一个已经被转发过的，那么丢弃。如果没转发过，那么复制并向所有邻居转发（除了从其接受到分组的那个结点）
	            
	         * **反向路径转发 RPF**：当一台路由器 B 接受到具有给定源地址 S 的广播分组时，仅当该分组到达的上一台路由器 A 正好位于 B 返回 S 的最短单播路径上时，B 才向所有邻居（除了 A）转发报文。否则丢弃报文。
	          
	      * **生成树广播**
			  * 一种简单的生成树方法：基于选择的中心结点建立一棵生成树：选择一个中心结点，然后向该中心结点单播加入树报文，但是这种方法生成的不一定是最低费用树（最小生成树）。
	         
		* **4.7.2 多播**
		   * 因特网中的网络层多播由两个互补的组建组成：IGMP 和多播路由选择协议。
		   * **IGMP**
		     * IGMP 运行在主机与它的第一跳路由器之间，IGMP 有三种报文：`membership_query`、`membership_report`，`membership_leave_group`。
		     
		     * 主机向路由器发送的 `membership_report` 表示应用程序向 IGMP 路由器告知它加入的多播分组。路由器向所有主机发送的 `membership_query` 来确定该接口上主机已加入的所有多播组集合。`membership_report` 用来响应 `membership_query`，但 `membership_report` 可以在由主机主动产生而不用非等到 `membership_query`。
		     * `membership_leave_group` 是可选的，因此即使主机不发送 `leave` 报文，路由器只要判断出没有主机响应 `query` 报文就知道，没有主机在这个多播组了。
		     
		   * **多播路由选择算法**
		   
		     * 多播路由选择算法用来协调遍及因特网内的多播路由器（包括相连的路由器），以便多播数据报能路由到其最终目的地。因此多播路由选择的目标是：找到一棵链路树，这些链路连接了所有属于该多播组的主机的第一跳路由器。
		     
		     * **使用单一共享树为指定多播组组中所有发送方分发流量** : 该树包括了所有该多播组的所有多播路由器（加入多播组主机的第一跳路由器）。使用基于中心的方法来构建多播树（选择中心，向中心单播加入树报文）
		     
		     * **为指定多播组中的每个源构建一棵路由选择树** : 对每个源使用剪枝 RPF 来决定多播树。
	



	 
	 
