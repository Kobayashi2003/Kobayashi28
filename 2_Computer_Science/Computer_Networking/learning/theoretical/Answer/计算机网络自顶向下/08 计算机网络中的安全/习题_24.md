#### P24 考虑下列伪 WEP 协议。其密钥是 4 比特，IV 是 2 比特。当产生密钥流时，IV 被附加到密钥的后面。假定共享的密钥是 1010。密钥流的 4 个可能输入如下:
#### 101000: 0010101101010101001011010100100 . . . 
#### 101001: 1010011011001010110100100101101 . . . 
#### 101010: 0001101000111100010100101001111 . . . 
#### 101011: 1111101010000000101010100010111 . . .
#### 假定所有报文都是 8 比特长。假定 ICV (完整性检查)是 4 比特长，并且通过用数据的后 4 比特异或数据的前 4 比特来计算。假定该伪 WEP 分组由 3 个字段组成：首先是 IV 字段，然后是报文字段，最后是 ICV 字段，这些字段中的某些被加密。
#### a. 我们希望使用 IV = 11 和 WEP 发送报文 m = 10100000。在这 3 个 WEP 字段中将有什么样的值？
#### b. 说明当接收方解密该 WEP 分组时，它恢复报文和 ICV
#### c. 假定 Trudy 截获了一个 WEP 分组 （不一定是 IV = 11 的 WEP 分组）并且试图在转发给接受者之前篡改该分组，假定 Trudy 先翻转了 ICV 的第一个 bit，为了通过接收者的 ICV 检查，她还必须翻转哪个比特？
#### d. 通过篡改 (a) 中 WEP 分组中的比特，解密所生成的报文，并验证完整性检查来评价你的答案。

   * a.
      * ICV = 1010 XOR 0000 = 1010
      * 因为IV = 11，所以密钥流的输入是  111110101000...
      * 加密 m 得到  10100000 XOR 11111010 = 01011010 
      * 加密 ICV 得到 1010 XOR 1000 = 0010
      * 所以 IV 是 11, 报文字段是 01011010，ICV 是 0010

   * b.
      * 当接收方收到报文时，首先使用明文 IV = 11 得到输入密钥流 111110101000...
      * 然后解密 m 得到 10100000,然后解密 ICV 得到 1010
      * 然后计算 m 的 ICV 得到 1010，对比两个 ICV 是否相同

   * c.
      * 既然 ICV 第一个 bit 被翻转，并且 ICV 是用 m 的前四比特和后四比特异或得到的，那么翻转 m 的第 1 比特或者第 5 比特就能通过 ICV 校验。
      
   * d.
      * (a) 中的分组为 
      
      |IV|加密 m| 加密 ICV|
      |:---:|:---:|:---:|
      | 11 | 01011010 | 0010 |
      
     * 篡改 ICV 第 1 bit 后得到 1010，接着再篡改 m 的第 1 比特得到 11011010

      |IV|加密 m| 加密 ICV|
      |:---:|:---:|:---:|
      | 11 | 11011010 | 1010 |
      
     * 接收者收到该报文后，先得到 IV = 11，那么得到输入密钥流为 111110101000...
     * 接下来通过输入密钥流解密 ICV 得到 1010 XOR 1000 = 0010
     * 接下来通过输入密钥流解密 m 得到 11111010 XOR 11011010 = 0010000
     * 计算 m 的 ICV 为 0010 XOR 0000 = 0010
     * 于是遭到篡改的 WEP 报文就通过了 ICV 校验。
     
     