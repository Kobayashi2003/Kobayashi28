### 3.1 ~ 3.3 节

#### R1 假定网络层提供了下列服务。在源主机中的网络层接收最大长度 1200 字节和来自运输层的目的主机地址的报文段。网络层则保证将该报文段交付给位于目的主机的运输层。假定在目的主机上能够运行许多网络应用进程。
#### a. 设计可能最简单的运输层协议，该协议将使应用层程序数据到达位于目的主机的所希望的进程。假设在目的主机的操作系统已经为每个运行的应用程序分配了一个 4 字节的端口号。
#### b. 修改这个协议，使它向目的进程提供一个 “返回地址”。
#### c. 在你的协议中，该运输层在计算机网络的核心中 “必须做任何事” 吗？

> a.
> 
> 运输层会在应用层报文首部附着一个 2 字节的目的端口字段，网络层会在运输层报文首部附着一个 4 字节的目的主机地址字段，这样的话，该运输层的 MSS 就是 1194 字节。当该报文段被网络层发出，到达目的主机的网络层时，目的主机的网络层将 4 字节主机地址字段拆除，将剩余部分上交给运输层，运输层根据报文段中的目的端口号将报文段交给绑定该端口的相应套接字，数据从套接字便流向了对应的应用程序。
> 
> b.
> 
> 此时，运输层会在应用层报文段附着两个字段，分别是 2 字节的目的端口号，2 字节的源端口号，网络层会在运输层报文段首部附着 4 字节的目的主机地址和 4 字节的源主机地址，这样的话，该运输层的 MSS 就是 1188 字节。于是数据在到达目的主机后，目的主机能够根据报文中的源主机字段和源端口字段给源主机上的应用程序回传数据。
> 
> c.
> 
> 不是，在我的协议中，网络中路由器只关心报文的网络层首部即主机地址，而不关心运输层附着的字段比如端口。毕竟，网络层中的构件都只实现了协议栈的底部 2 层或 3 层，而运输层只在端系统中实现。

#### R2 考虑有一个星球，每个人都属于某个六口之家，每个家庭都住在自己的房子里，每个房子都有一个唯一的地址，并且某给定家庭中的每一个人都有一个独特的名字。假定该星球有一个从源家庭到目的家庭交付信件的邮政服务。该邮政服务要求：1、在一个信封中有一封信；2、在信封上清楚地写上目的家庭的地址（并且没有别的东西）。假设每个家庭有一名家庭成员代表为家庭中的其他成员收集和分发信件。这些信没有必要提供任何有关信的接收者的提示。
#### a. 使用对上面复习题 R1 的解决方案作为启发，描述家庭成员代表能够使用的协议，以从发送家庭成员向接收家庭成员交付信件。
#### b. 在你的协议中，该邮政服务必须打开信封并检查信件能容才能提供它的服务吗？

> a.
> 
> 家庭成员代表首先在信件底部填写发送该信件的家庭成员的名字，接着把信件打包，在信封上写下目的家庭的地址，然后把信封交给邮政服务，在目的家庭中 ，家庭成员代表拆开信封，根据每个信件底部的家庭成员的名字，分别把信交给不同的家庭成员手中。
> 
> b.
> 
> 邮政服务不用打开信封，只用检查信封上目的家庭的地址就能提供它的服务。

#### R3 考虑在主机 A 和主机 B 之间有一条 TCP 连接。假设从主机 A 传送到主机 B 的 TCP 报文段具有源端口号 x 和目的端口号 y。对于从主机 B 传送到主机 A 的报文段，源端口号和目的端口号分别是多少？

> A 传送到 B 的 TCP 报文段的源目的端口号分别是 x 和 y,说明 A 上套接字对应端口 x, B 上套接字对应端口 y，所以 B 传送给 A 时，源和目的分别是 y 和 x。

#### R4 描述应用程序开发者为什么可能选择在 UDP 上运行应用程序而不是在 TCP 上运行的原因。

> 1. 该应用想要以尽可能快的最低速率发送数据，而不想经受拥塞控制遏制发送速率
> 2. TCP 的首部字段有 20 字节，UDP 首部字节有 8 字节，因此 TCP 报文段会引入更多的传输时延
> 3. TCP 连接的连接建立过程需要握手，因此相比 UDP 会引入建立连接时延。
> 4. 该应用能容忍数据部分丢失

#### R5 在今天的因特网中，为什么语音和图像流量常常是经过 TCP 而不是经 UDP 发送。（提示：我们寻找的答案与 TCP 的拥塞控制没有关系）

> 1. 因为大多数防火墙被配置为阻止 UDP 流量，而使用 TCP 流量可以通过防火墙。
> 2. UDP 没有拥塞控制，因此会导致发送方和接收方的高丢包率，而且还会挤垮 TCP 流量。

#### R6 当某应用程序运行在 UDP 上时，该应用程序可能得到可靠数据传输吗？如果能，如何实现？

> 可能
> 
> UDP 的下层信道是不可靠的，并且 UDP 只提供数据交付和差错控制两种最基本的运输层服务，因此想要让建立在 UDP 上的应用程序得到可靠的数据传输，可以在应用程序内部建立可靠机制来保证。
> 
> 使用重传机制，带序号 ACK 确认报文来解决比特差错的问题，使用定时器和重传来解决信道丢包问题。

#### R7 假定在主机 C 上的一个进程有一个具有端口号 6789 的 UDP 套接字。假定主机 A 和主机 B 都用目的端口号 6789 向主机 C 发送一个 UDP 报文段。这两台主机的这些报文段在主机 C 都被定位到相同的套接字吗？如果是这样的话，在主机 C 的该进程将怎样知道源于两台不同主机的这两个报文段呢？

> 是的，目的端口号相同，源端口号不同的两个报文段会被定位到同一个套接字，因为 UDP 套接字的标识符是一个二元组：目的 IP 和目的 端口号。
> 
> 操作系统会将网络层报文中的 IP 地址提取出来交给应用层，比如在 `struct sockaddr_in` 中的 `sin_addr.s_addr` 字段中填写 IP 地址，这样在 `recvfrom(...)` 方法返回后，就可以从该字段中取出发送方的 IP 地址。

#### R8 假定在主机 C 端口 80 上运行的一个 Web 服务器。假定这个 Web 服务器使用持续连接，并且正在接收来自两台不同主机 A 和 B 的请求。被发送的所有请求都通过位于主机 C 的相同套接字吗？如果它们通过不同的套接字传递，这两个套接字都具有端口 80 吗？讨论和解释之。

> 第一问
> 
> 对于 TCP 连接，先创建一个欢迎套接字，在接入新连接后又创建一个正式通信的连接套接字，该套接字是通过四元组来标识的，即 (目的 IP, 目的端口，源 IP, 源端口)
，因此来自不同主机 A 和 B 的请求，一定会具有不同的 IP 地址，因此请求会通过位于主机 C 的不同的套接字。
> 
> 第二问
> 
> 是的，这两个套接字都使用相同的端口 80 来标识。下列是实验
> 
> 在主机 A 上运行一个 [TCPServer.c](https://github.com/YangXiaoHei/Networking/blob/master/计算机网络自顶向下/02%20应用层/progs/TCPServer.c) 程序，在另外两台主机 B 和 C 上运行 [TCPClient.c](https://github.com/YangXiaoHei/Networking/blob/master/计算机网络自顶向下/02%20应用层/progs/TCPClient.c) 来连接主机 A，并打印主机 A 创建的连接套接字所使用的端口和 IP 地址（使用 `getsockname` 函数），结果如下：
> 
~~~
wait to accept....
accpet succ! connnection from [xxxx:52253]
OS assign a new connfd for this connection [xxxx:5000]
wait to read data...
peer close socket, read finished!
wait to accept....
accpet succ! connnection from [xxxx:49437]
OS assign a new connfd for this connection [xxxx:5000]
wait to read data...
~~~






