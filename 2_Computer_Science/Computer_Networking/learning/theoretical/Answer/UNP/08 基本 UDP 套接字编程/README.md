* 实践经验
   * TCP 服务器大多是并发的，而 UDP 服务器大多是迭代的。

* UDP 源端口如何选取？
   * 对于一个 UDP 套接字，如果其进程首次调用 sendto 时它没有绑定一个本地端口，那么内核就在此时为它选择一个临时端口。跟 TCP 一样，客户可以显示调用 bind，不过很少这样做。
   
* UDP 源 IP 如何选取？
   * ⚠️ 客户的临时端口是第一次调用 sendto 时一次性选定的，不能改变。然而如果是多宿主机的话，客户的 IP 地址却可以随客户发送的每个 UDP 数据报而变动（假设客户没有绑定一个具体的 IP 地址到其套接字上）。这由路由选择来决定。
   * ⚠️ 在多宿主机上，如果客户绑定了一个 IP 地址到套接字上，但是内核决定外出数据报必须从另一个数据链路出发，那么此时，IP 数据报将包含一个不同于外出链路 IP 地址的源 IP 地址（即绑定的那个）。

* UDP 服务器如何获取套接字地址？
   * 源 IP : recvfrom
   * 源端口 : recvfrom
   * 目的 IP : recvmsg
   * 目的端口 : getsockname

* TCP 服务器如何获取套接字地址？
   * 源 IP : accept
   * 源端口 : accept
   * 目的 IP : getsockname
   * 目的端口 : getsockname

* UDP 错误
   * 若服务器未运行，此时 sendto 尽管成功返回，但由服务器返回的 ICMP 端口不可达消息不提交给客户端，除非是已连接的 udp 套接字，否则客户端永远阻塞在 recvfrom 调用上。

* UDP 性能
  * 在一个未连接套接字上通过 sendto 发送两个数据报的步骤如下：
     * 连接套接字
     * 输出第一个数据报
     * 断开套接字连接
     * 连接套接字
     * 输出第二个数据报
     * 断开套接字连接
     * ⚠️ 这种情况，内核复制两次套接字地址。
   * 连接套接字后通过 sendto 或 write 发送两个数据报的步骤如下:
      * 连接套接字
      * 发送第一个数据报
      * 发送第二个数据报
      * ⚠️这种情况，内核只复制一次套接字地址。

* 验证 UDP 缓冲区溢出而丢包的命令
  * netstat -s -p udp 记录第一次数据
  * 启动服务器，启动客户端发送 udp 数据报
  * netstat -s -p udp 记录第二次数据
  * 两次相减验证结果。

* UDP 外出接口的确定
  * 调用 connect，然后调用 getsockname
     







