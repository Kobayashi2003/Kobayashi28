#### 16.1 在关于图 16-10 的讨论中我们提到，父进程必须调用 shutdown 而不是 close。这是为什么？

   * close 的默认动作是立即返回，丢弃接收缓冲区中所有数据，尝试发送发送缓冲区中数据，如果调用 close，那么假如在 close 后服务器的数据才到达，那么这些数据将被全部丢弃。
   * shutdown 和 `SHUT_WR` 的默认动作是发送发送缓冲区中所有数据，后接一个 FIN。而不影响接收缓冲区。 

#### 16.2 在图 16-10 中，如果服务器进程过早终止，而客户子进程收到来自服务器的 EOF 后不通知父进程就终止，将会发生什么？

   * 子进程不通知父进程，那么父进程将继续向套接字写数据，于是第一个发送出去的分组导致服务器以 RST 响应，继续对收到 RST 的套接字写数据，导致内核向进程发送 SIGPIPE 信号。

#### 16.3 在图 16-10 中，如果父进程在子进程之前意外死亡，而子进程随后从套接字读到 EOF，将会发生什么？

   * 子进程将被 init 进程领养，而 kill 无权向 init 发送信号，但是如果进程以超级用户特权运行就不一样了，因此需要检查 getppid 的返回值，如果是 1 的话就不发信号。 

#### 16.4 在图 16-11 中如果删掉以下两行将会发生什么？

~~~
if (n == 0)
	goto done;
~~~
  
  * select 将被调用，并且返回套接字可写事件。因此在 n == 0 时直接 goto done 可以避免 select 调用。

#### 16.5 我们在 16.3 节说过，来自对端的数据有可能在本端的 connect 调用返回前到达套接字。这是如何发生的？

   * 客户端的 connect 是在收到服务器的 ACK-SYN 后返回的，因此假如客户端主机比较忙，必须先处理完其他数据，再处理这个 ACK-SYN，那么此时服务器可能已经发过来了很多数据，因此这些数据是在 connect 返回之前就到达套接字的。

