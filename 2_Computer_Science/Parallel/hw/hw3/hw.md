# Problem 1.1

1. 在给出的场景中，两个线程可能会发生死锁。分析如下：

- 时间0时，线程0获取`mutex0`，线程1获取`mutex1`。
- 时间1时，线程0尝试获取`mutex1`，但其已经被线程1获取，因此线程0阻塞。线程1同理。此时两个线程将陷入死锁。

2. 如果使用忙等待（标志标量）替代互斥锁，仍然存在一些问题：

- 忙等待（标志变量）不会死锁，但等待的线程会一直占用CPU，导致CPU空转，降低CPU利用率。

3. 如果使用信号量替代互斥量，仍然可能发生死锁。分析如下：

给出下例：

```c
// 定义两个信号量
sem_t sem1, sem2;
sem_init(&sem1, 0, 1);  // 初值为1
sem_init(&sem2, 0, 1);  // 初值为1

// 线程1
void thread1() {
    sem_wait(&sem1);    // 获取信号量1
    // 做一些操作
    sem_wait(&sem2);    // 尝试获取信号量2（可能阻塞），point1
    // 临界区
    sem_post(&sem2);
    sem_post(&sem1);
}

// 线程2
void thread2() {
    sem_wait(&sem2);    // 获取信号量2
    // 做一些操作
    sem_wait(&sem1);    // 尝试获取信号量1（可能阻塞）
    // 临界区
    sem_post(&sem1);
    sem_post(&sem2);
}
```

我们假设thread1在point1之前获取了sem1，同时thread2在point2之前获取了sem2。那么在thread1和thread2分别执行到point1和point2时，将发生死锁。

# Problem 1.2

所有的并发组合均不安全：

1. 两个Delete：可能删除同一节点，或者一个线程删除另一个线程正在操作的节点
2. Insert和Delte：Delte操作可能会删除Insert操作正在操作的节点，或者Insert操作可能会插入到已删除的位置
3. Member和Delete：Member可能访问被释放的节点
4. 两个Insert：可能插入到同一位置导致覆盖
5. Insert和Member：Member可能会访问到未完成插入的中间状态

# Problem 1.3

不安全。分析如下：

在释放读锁和获取写锁之间存在一个窗口期。在这个窗口期间，其它线程可能修改链表结构。当前线程第二阶段可能访问到被修改的链表结构，导致出错。

# Problem 2

1. 此时线程处理的数据范围如下：

- 线程0：处理 0-1999 行
- 线程1：处理 2000-3999 行
- 线程2：处理 4000-5999 行
- 线程3：处理 6000-7999 行

2. 分析线程0和线程2：

- 线程0处理的最后一个元素为y[1999]，线程2处理的第一个元素为y[4000]。
- 这两个元素之间的距离为$4000 - 1999 = 2001$个元素，远超一个缓存行的大小。
- 故线程0和线程2的处理向量y时不存在重叠，故不会发生伪共享。

3. 如果线程 0 和线程 3 被分配到不同的处理器，会发生伪共享吗？

实际上我没能够很好的理解题目，如果你是指像上面的线程0和线程2一样的分析，那么答案时不会，理由可以参考上面2的分析。

如果你是指：线程0和线程3被分配到与线程1和线程2不同的处理器，会发生为共享吗？那么分析见下：

- 线程0处理的最后一个元素为y[1999]，线程1处理的第一个元素为y[2000]
- 而$2000 \mod 8 = 0$，故元素y[1999]恰好在缓存行的末尾，而y[2000]恰好在缓存行的开头。两者不发生重叠，故不会发生伪共享。
- 线程2与线程3同理。

# Problem 3

1. 可能的线程分配方式：

- 线程0和1一组，线程2和3一组
- 线程0和2一组，线程1和3一组
- 线程0和3一组，线程1和2一组

2. 方案如下：

- 线程分配方案：线程0和1一组，线程2和3一组
- 向量元素到缓存行的分配方式如下：

| y[0] | y[1] | y[2] | y[3] | 0 | 0 | 0 | 0 | 
| 0 | 0 | 0 | 0 | y[4] | y[5] | y[6] | y[7] |

其中线程0处理y[0]，y[1]，线程1处理y[2]，y[3]，线程2处理y[4]，y[5]，线程3处理y[6]，y[7]。
