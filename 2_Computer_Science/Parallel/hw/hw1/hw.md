# Problem 1.1

两种策略：

1. 写直达策略（Write-Through）：写直达缓存通过在写入缓存的同时更新主内存中的数据来处理这个问题。

- 优点：保证主存和缓存数据的一致性
- 缺点：每次写入缓存都要写入主存，导致写入速度变慢

2. 写回策略（Write-Back）：写回缓存会将缓存中的数据标记为“脏”，当缓存行被来自内存的新缓存行替换时，这个“脏”的缓存行会被写回到内存中。

- 优点：减少写入主存的次数，提高写入速度
- 缺点：需要额外的缓存标记来标识缓存行是否被修改，增加了缓存控制的复杂性

# Problem 1.2

概念解释：

- 时间局部性：如果一个数据被访问，那么在近期它可能会再次被访问

- 空间局部性：如果一个数据被访问，那么它周围的数据也可能很快会被访问


代码分析：

- 时间局部性分析：

1. 变量sum在循环中被重复访问和修改，体现了时间局部性
2. 循环变量i和j在循环中被频繁使用，体现了时间局部性

- 空间局部性分析：

对二维数组a的访问体现了空间局部性：

- C语言中二维数组是按行存储的
- 内层循环j是按照连续的内存位置访问数组元素（a[i][0], a[i][1], ..., a[i][n-1]）
- 这种访问模式充分利用了CPU缓存的特性，因为当加载一个缓存行时，临近的数组元素很可能也被加载到缓存中，从而减少了缓存未命中的次数

# Problem 1.3

- SIMD（Single Instruction Multiple Data）：所有处理单元同步执行同一指令，操作不同数据元素，适合规则数据并行处理。

- MIMD（Multiple Instruction Multiple Data）：多个处理单元可以独立执行不同指令，更加灵活，也更加适合处理不规则数据。

- 这两种并行计算模型的主要区别在于指令流的数量和处理单元的独立性。

# Problem 2.1

my_left = $\left\lfloor \frac{n}{p} \right\rfloor \times i + \min(i, n \mod p)$

my_right = $\left\lfloor \frac{n}{p} \right\rfloor \times (i + 1) + \min(i + 1, n \mod (p + 1))$

# Problem 2.2

当n=10^5，p=1000时，每个核心处理100个元素。每个local_sum的计算需要：

1. 2次乘法计算my_left和my_right
2. 100次加法计算local_sum
3. 总耗时为2 * 10 + 100 = 120

并行计算后，主函数需要执行1000次加法，耗时1000 * 1 = 1000

因此总耗时为120 + 1000 = 1120

# Problem 2.3

串行时间：$T_{serial} = 10^5$

并行时间：$T_{parallel} = 1120$

加速比：$S = T_{serial} / T_{parallel} = 10^5 / 1120 \approx 89.29$

效率：$E = S / p = 89.29 / 1000 = 0.008929$

可以看出加速比并不理想。其不理想的原因主要在于最后的累加部分，或许可以考虑将最后的串行累加更改为并行归约累加的方式。


# Problem 3.1

根据Amdahl定律，我们可以求得最大加速比：

$S = \frac{1}{0.15 + \frac{0.85}{10}} \approx 4.26$

可以达到4倍的加速比，需要10个核心，加速比为4.26


# Problem 3.2


$$T_{serial} = n$$
$$T_{parallel} = \frac{n}{p} + \log_2(p)$$

效率的表达式为：

$$E = \frac{T_{serial}}{p \cdot T_{parallel}} = \frac{n}{p \cdot (\frac{n}{p} + \log_2(p))} = \frac{n}{n + p \log_2(p)}$$

当$p$以倍率$k$增加，即$p = kp$，设$n$需要变为$n'$，以保持$E$不变，则有：

$$\frac{n}{n + p \log_2(p)} = \frac{n'}{n' + kp \log_2(kp)}$$

解这个方程，可以得到：

$$n' = n \cdot \frac{k\log_2(kp)}{\log_2(p)}$$

从而可看出该程序是弱可扩展的，因为$n$随$p$增长而增长，但非严格线性。
