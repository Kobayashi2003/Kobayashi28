# Problem 1.1

- Fork-Join模型：程序开始时仅有一个主线程，当遇到并行区域时，主线程创建一组工作线程形成线程组。所有线程并行执行代码块，执行完毕后合并回主线程。

- 主线程角色：负责初始化并行区域、分配任务，并在并行结束后汇总结果

- 工作线程角色：执行并行区域内的任务，处理分配给自己的子任务

# Problem 1.2

- &&（逻辑与）的归约值：true/1
- ||（逻辑或）的归约值：false/0
- &（位与）的归约值：全1
- |（位或）的归约值：全0
- ^（位异或）的归约值：全0

# Problem 2.1

## Problem 2.1.a

循环使用了`schedule(static, 2)`，表示采用静态调度方式，块大小为2。4个线程分配如下：

- 线程0：i=0, 2，8，9
- 线程1：i=1, 3，10，11
- 线程2：i=4, 6，12，13
- 线程3：i=5, 7，14，15

## Problem 2.1.b

- 问题：由于`process_item(i)`的计算时间于`i`成正比，使用静态分配将回导致负载分配不均衡。前几个线程处理小`i`（耗时短），后几个线程处理大`i`（耗时长），线程间等待时间增加。
- 优化方案：改用`schedule(dynamic, 1)`，表示动态调度，允许线程动态获取未完成的迭代、平衡负载。

# Problem 2.2

- 存在竞争条件：`total_sum += data[i]`将可能导致多个线程同时读写`total_sum`，导致结果不一致。
- 修复方式：
  - 1：使用归约子句：
    ```c
    #pragma omp parallel for reduction(+:total_sum)
    ```
  - 2：使用原子操作：
    ```c
    #pragma omp parallel for
    for (int i = 0; i < n; i++) {
      #pragma omp atomic
      total_sum += data[i];
    }
    ```