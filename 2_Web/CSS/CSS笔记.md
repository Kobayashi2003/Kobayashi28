# CSS

> 为网络添加样式

[toc]

## 术语解释

CSS规则 = 选择器 + 声明块

### 选择器

> 选择器：选中元素（花括号前面），用来确定样式的范围

1. **ID选择器**：选中的是对应**ID值**的元素`
```CSS
<head>
    ……
    <style>
        #test{
            color:red;
            background-color:lightblue;
            text-align:center;
        }
    </style>
</head>
<body>
    <h1>……</h1>
    <p id="test">……</p>
    <p>……</p>
</body>
```

2. **元素选择器**：可以选择页面上所有的同一元素，与该元素的位置无关
```CSS
<head>
    ……
    <style>
        p{
            color:red;
            background-color:lightblue;
            text-align:center;
        }
    </style>
</head>
<body>
    <h1>……</h1>
    <p>……</p>
    <p>……</p>
</body>
```

3. **类选择器**
```CSS
<head>
    ……
    <style>
        .red{
            color: red;
            background-color: lightblue;
            text-align: center;
        }
        .big-center{
            font-size: 3em;

            text-align: center;
        }
    </style>
</head>
<body>
    <h1 class="red big-center">……</h1>
    <p class="red">……</p>
    <p>……</p>
</body>
```

### 声明块

> 声明块：（出现在花括号内）声明块中包含很多声明（属性），每一个声明（属性）表达了某一方面的样式

## CSS代码书写位置

1. **内部样式表**

> 书写在style元素内部（通常把该元素放在head标签内，方便浏览器在读取网页时能最先将样式读取，但并不是一定放在这）

2. 内联样式表
```CSS
直接书写在元素的style属性中
<h1 style="color:red; background-color:lightblue;">
```

3. 外部样式表[推荐]

> 将样式书写到独立的CSS文件中

```CSS
<head>
    ……
    <link rel="stylesheet" href="./CSS/index.css">
</head>
```
1). 外部样式表可以解决多页面样式重复的问题
2). 有利于浏览器缓存，从而提高页面响应速度
3). 有利于代码分离（HTML和CSS代码分离），更容易阅读和维护

# 常见样式声明

1. **color**

元素内部的文字颜色

**预设值**：定义好的单词

**三原色，色值**：光学三原色（红、绿、蓝），每种颜色可以使用 0-255 之间的数字来表达，色值

```html
rgb表示法：
color:rgb(0,140,140);

hex（16进制）表示法：
#红绿蓝
color:#008c8c;
```
<!--
淘宝红：#ff4400 #f40
黑色：#000
白色：#fff
红色：#f00
绿色：#0f0
蓝色：#00f
灰色：#ccc
-->

2. **background**

元素背景颜色

3. **font-size**

元素内部文字的尺寸大小

单位：
1) px：绝对单位 像素，（简单理解为文字的高度占多少个像素）
2) em：相对单位 相对于父元素的字体大小（最终都会换算为真实的像素值）
<!-- em指的是父元素的字体大小 -->

每个元素必须有字体大小，如果没有声明，则直接使用父元素的字体大小，如果没有父元素，则使用基准字号（浏览器所设置的字号）

> user agent: UA，用户代理（浏览器）

<!-- CSS中的注释方式为 /*（注释内容）*/ -->

4. **font-weight**

文字粗细程度，可以取值为数字，可以取值为预设值（normal（相当于 400）、bold（相当于 700））

> strong元素，默认的样式为加粗

```CSS
<strong>
    表示重要的，不能忽略的
</strong>
```

1. **font-family**

文字类型

必须用户计算机中存在的字体才会有效

使用多种字体，以匹配

```CSS
div{
    font-family: consolas,微软雅黑,Arial,sans-serif;
}
/* sans-serif，非衬线字体 */
```

6. **font-style**

字体模式，通常用它设置斜体（italic）

> i元素，默认样式是倾斜字体；实际使用的时候，通常用它表示一个图标（非正式）

> em元素，默认样式为斜体字体，表示强调内容

7. **text-decoration**

文本修饰（给文本加线）

> a元素：默认样式为添加下划线
> del元素：表示错误的内容，默认样式为 text-decoration: line-through
> s元素：表示过期的内容，默认样式也为 line-through

8. **text-indent**

首行文本缩进
<!-- indent：缩进 -->

9. **line-height**

每行文本的高度，该值越大，每行文本的距离越大

设置行高为容器的高度，可以让单行文本垂直居中

行高可以设置为纯数字，表示相当于当前元素的字体大小

10. **width**

宽度

11. **height**

高度

12. **letter-space**

文字间隙

13. **text-aligh**

元素内部文字的水平排列方式'


# 选择器

选择器的作用：帮助你精准地选中想要的元素

## 简单选择器

1. ID选择器
2. 元素选择器
3. 类选择器
4. 通配符选择器

*，表示选中所有元素

```CSS
* {
    color:red;
}
```

5. 属性选择器

根据属性名和属性值选中元素

```CSS
/* 选中所有具有href属性的元素 */
[href] {
    color:red;
}

/* 选中具有href属性并且具有相应属性值的元素 */
[href=value] {
    color:blue;
}

[attr~=value] {
    /* 匹配带有一个名为attr的属性的元素，其值正为value，或者匹配带有一个attr属性的元素，其值有一个或者更多，至少有一个和value匹配。
    注意，在一列中的好几个值，是用空格隔开的。 */
}

[attr|=value] {
    /* 匹配带有一个名为attr的属性的元素，其值可正为value，或者开始为value，后面紧随着一个连字符。 */
}

/* 其它的具体查mdn */
```

6. 伪类选择器

选中某些元素的某种状态

<!-- 元素前要加 :  -->

hover：鼠标悬停状态

```CSS
a:hover {/* 选中鼠标悬停时候的a元素（若:前不写元素名称则默认选中所有元素） */
    color:red;
}
```

active：激活状态，一般是指鼠标按下状态

```CSS
a:active {/* 选中鼠标按下时的a元素 */
    color:red;
}
```

link：超链接未访问时的状态

```CSS
a:link {
    color:blue;
}
```

visited：超链接访问过后的状态

```CSS
a:visited {
    color:black;
}
```

如果需要同时书写这四个元素，则需要按照link、visited、hover、active的顺序进行书写

7. 伪元素选择器

<!-- 元素前要加 :: -->

before

```CSS
span::before {/* before将会自动生成一个无名元素，且该元素将会出现在span的最前部分 */
    /* 特殊元素content,只能出现在before或after中，用于表示该元素中的内容 */
    content:"《》";
}
```

after

用法类似于before

## 选择器的组合

1. 并且 —— （什么都不加）

```CSS
p.red {
    text-indent: 2em;
    line-height: 2;
}
```

2. 后代元素 —— 空格

```CSS
.red li {/* 选中的是class为red的元素的后代元素ui */
    color: red;
}
```

3. 子元素 —— >

```CSS
.abc > .bcd {
    /*blank*/
}
```

4. 相邻兄弟元素 —— +

```CSS
.special + li {/* 选中class为special的元素和它的下一个li元素*/
    /*blank*/
}
```

5. 兄弟元素 —— ~

```CSS
.special ~ li {/* 选中class为special的元素以及它下面的所有li元素*/
    /*blank*/
}
```

## 选择器的并列

多个选择器，用逗号分隔

语法糖

```CSS
div,
p {
    /*blank*/
}
```

# 层叠

> 层叠样式表

声明冲突：同一份样式，多次应用到同一个元素

层叠：解决声明冲突的过程，浏览器自动处理（权重计算）

## 1. 比较重要性

重要性从高到低：

> 作者样式表：开发者书写的样式

1）作者样式表中的!important样式

2）作者样式表中的普通样式

3）浏览器默认样式表中的样式

## 2. 比较特殊性

总体规则：选择器选中的范围越窄越特殊

具体规则：通过选择器，计算出一个4位数（xxxx）

1. 千位：如果是内敛样式，记1，否则记0
2. 百位：等于选择器中所有id选择器的数量
3. 十位：等于选择器中所有类选择器、属性选择器、伪类选择器的数量
4. 个位：等于选择器中所有元素选择器、伪元素选择器的数量

<!-- 该四位数是逢256进一，因此在实际使用的时候并不需要考虑进位的问题 -->

## 3. 比较原次序

代码书写**靠后**的胜出

## 应用

1. 重置样式表

书写一些作者样式，覆盖浏览器的默认样式

重置样式表，覆盖浏览器的默认样式

常见的重置样式表：normalize.css、reset.css、meyer.css

2. 爱恨法则

link > visited > hover > active（由使用逻辑安排其原次序）


# 继承

子元素会继承父元素的**某些**CSS属性

通常，跟**字体内容相关**的属性都能被继承


# 属性值的计算过程

一个元素一个元素依次渲染，顺序按照页面文档的树形目录结构进行

渲染每个元素的前提条件：该元素的所有CSS属性必须有值

一个元素，从所有属性都没有值，到所有属性都有值，这个计算过程，叫做属性的计算过程

1. **确定声明值**

参考样式表中没有冲突的声明，作为CSS属性值

2. **层叠冲突**

对样式表有冲突的声明使用层叠规则，确定CSS属性值
<!-- 比较重要性 特殊性 源次序 -->

3. **使用继承**

对仍然没有值的属性，若可以继承，则继承父元素的值

4. **对仍然没有值的属性，使用默认值**

特殊的两个CSS取值：

- **inherit**：手动（强制）继承，将父元素的值取出应用到该元素

- **initial**：初始值，将该属性设置为默认值


# 盒模型

box：盒子，每个元素在页面中都会生成一个矩形区域（盒子）

盒子类型：

1. 行盒，display等于inline的元素
2. 块盒，display等于block的元素

display默认值属性为inline

行盒在页面中不换行，块盒在页面中独占一行

浏览器默认样式表设置的块盒：容器元素，h1~h6，p

常见的行盒：span、a、img、video、audio

## 盒子的组成部分

无论是行盒、还是块盒、都由下面几个部分组成，从内到外分别是：

1. 内容 content

width、height，设置的是盒子内容的宽高

内容部分通常叫做整个**盒子的内容盒 content-box**

2. 填充（内边距） padding

盒子边框到盒子内容的距离

padding-left、padding-right、padding-top、padding-bottom

padding：简写属性

padding：上 右 下 左

填充区 + 内容区 = **填充盒 padding-box**

3. 边框 border

边框 = 边框样式 + 边框宽度 + 边框颜色
<!-- 都为简写属性（速写属性） -->
边框样式：border-style
边框宽度：border-width
边框颜色：border-color

边框 + 填充区 + 内容区 = **边框盒 border-box**

4. 外边距 margin

边框到其它盒子的距离

margin-top、margin-left、margi-right、margin-bottom


# 盒模型应用

## 改变宽高范围

默认情况下， width 和 height 设置的是内容盒宽高

衡量设计稿的时候，往往使用的是边框盒，但设置 width 和 height ，则设置的是内容盒

1. 精确计算
2. CSS3: box-sizing

## 改变背景覆盖范围

默认情况下，背景覆盖边框盒

可以通过 background-clip 进行修改

## 溢出处理

overflow，控制内容溢出边框盒后的处理方式

## 断词规则

word-break，会影响文字在上面位置被截断换行

normal：普通，CJK字符（文字位置截断），非CJK字符（单词位置截断）

break-all：截断所有，所有字符都在文字处截断

keep-all：保持所有，所有文字都在单词之间截断

## 空白处理

white-space: nowrap


# 行盒的盒模型

常见的行盒：包含具体内容的元素

span、strong、em、i、img、video、audio

## 显著特点

1. 盒子沿着内容延伸
2. 行盒不能设置宽高

调整行盒的宽高，应该使用字体大小、行高、字体类型，间接调整

3. 内边距（填充区）

水平方向有效，垂直方向仅会影响背景，不会实际占据空间

4. 边框

水平方向有效，，垂直方向不会实际占据空间

5. 外边距

水平方向有效，垂直方向不会实际占据空间

## 行块盒

display: inline-block 的盒子

1. 不独占一行
2. 盒模型中的所有尺寸都有效

## 空白折叠

空白折叠：发生在行盒（行块盒）内部 或 行盒（行块盒）之间


## 可替换元素 和 非可替换元素

大部分元素，页面上显示的结果，取决于元素内容，称为“非可替换元素”

少部分元素，也买你上显示的结果，取决于元素属性，称为“可替换元素”

可替换元素：img，video，audio


绝大部分可替换元素均为行盒

可替换元素类似于行块盒，行模型中所有尺寸都有效


# 常规流

盒模型：规定单个盒子的规则

视觉格式化模型（布局规则）：页面中多个盒子排列规则

视觉格式化模型，大体将页面中盒子的排列分为三种方式：

1. 常规流
2. 浮动
3. 定位

## 常规流布局

常规流、文档流、普通文档流、常规文档流

所有元素，默认情况下，都属于常规流布局

总体规则：块盒独占一行，行盒水平依次排列

包含块（containing block）：每个盒子都有它的包含块，包含块决定了盒子的排列区域

绝大部分情况下：盒子的包含块为器父元素的内容盒

**块盒**

1. 每个块盒的总宽度，必须刚好等于包含块的宽度

宽度的默认值：auto

auto：将剩余空间吸收掉

width吸收能力强于margin

若宽度、边框、内边距、外边距计算后，仍有剩余空间，该剩余空间被margin-right全部吸收

在常规流中，块盒在其包含块中居中，可以定宽，然后左右margin设为auto

2. 每个块盒垂直方向上的auto值

height:auto，适应内容的高度

margin:auto，表示0

3. 百分比取值

padding、宽、margin的取值为百分比

以上的所有百分比相对于包含块的宽度

高度的百分比：

1. 包含块的宽度取决于子元素的宽度，设置百分比无效
2. 包含块的高度不取决于子元素的宽度，百分比相对于父元素的高度


4. 上下外边距的合并

两个常规流块盒，上下边距相邻，会进行合并

两个外边距取最大值

# 浮动

## 应用场景

1. 文字环绕
2. 横向排列、

## 浮动的基本特定

修改float属性值为：

- left：左浮动，元素靠上靠左
- right：右浮动，元素靠上靠右

默认值为 none

1. 当一个元素浮动后，元素必定为块盒（更改display属性为block）
2. 浮动元素的包含块，和常规流一样，为父元素的内容盒

## 盒子尺寸

1. 宽度为auto时，适应内容宽度
2. 高度为auto时，与常规流一致，适应内容高度
3. margin为auto，为0
4. 边框、内边框，百分比设置与常规流一样

## 盒子排列

1. 左浮动的盒子靠上靠左排列
2. 右浮动的盒子靠上靠右排列
3. 浮动盒子在包含块中排列时，会避开常规流盒子
4. 常规流块盒在排列时，无视浮动盒子
5. 行盒在排列时，会避开浮动盒子
6. 外边距合并不会发生

> 如果文字没有在行盒中，浏览器会自动生成一个行盒包含文字，该行盒称为匿名行盒

## 高度坍塌

高度坍塌的根源：常规流盒子的自动高度，在计算时，不会考虑浮动盒子

解决方式：
清除浮动，涉及css属性：clear

- 默认值：none
- left：清除左浮动，该元素必须出现在前面所有左浮动盒子的下方
- right：清除右浮动，该元素必须出现在前面所有右浮动盒子的下方
- both：清除左右浮动，该元素必须出现在前面所有浮动盒子的下方

# 定位

定位：手动控制元素在包含块中的精准位置

涉及的CSS属性：position

## position属性

- 默认值：static，静态定位（不定位）
- relative：相对定位
- absolute：绝对定位
- fixed：固定定位

一个元素只要position的取值不是static，认为该元素是一个定位元素

定位元素会脱离文档流（相对定位除外）

一个脱离了文档流的元素：

1. 文档流中的元素摆放时，会忽略脱离了文档流的元素
2. 文档流中元素计算自动高度时，会忽略脱离了文档流的元素


## 相对定位

不会导致元素脱离文档流，只是让元素在原来的位置上进行偏移

可以通过四个CSS属性对设置其位置：

- left
- right
- top
- bottom

盒子的偏移不会对其它盒子造成任何影响

## 绝对定位

1. 宽高为auto，适应内容
2. 包含块变化：找祖先元素中第一个定位元素，该元素的填充盒为其包含块，若找不到，则它的包含块为整个网页（初始化包含块）

## 固定定位

其它情况和绝对定位完全一样

包含块不同：固定为视口（浏览器的可视窗口）

## 定位下的居中

某个方向居中：

1. 定宽（高）
2. 将左右（上下）距离设置为0
3. 将左右（上下）margin设置为auto

绝对定位和固定定位中，margin为auto时，会自动吸收剩余空间

## 多个定位元素重叠时

堆叠上下文

设置z-index，通常情况下，该值越大，越靠近用户

只有定位元素设置z-index无效

z-index可以是负数，如果是负数，则遇到常规流、浮动元素，则会被其覆盖

## 补充

- 绝对定位，固定定位元素一定是块盒
- 绝对定位、固定定位元素一定不是浮动
- 没有外边距合并