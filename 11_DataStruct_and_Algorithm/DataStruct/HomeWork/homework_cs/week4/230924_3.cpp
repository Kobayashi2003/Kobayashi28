#include <iostream>
#include <vector>

using namespace std;

vector<vector<int>> fullPermulation(vector<int> && nums) {
    if (nums.empty()) return {};
    if (nums.size() == 1) return {nums};

    vector<vector<int>> res;
    for (unsigned i = 0; i < nums.size(); i++) {
        swap(nums[0], nums[i]);

        vector<vector<int>> sub_res = 
            fullPermulation(vector<int>(nums.begin() + 1, nums.end()));

        for (auto &v : sub_res) {
            v.insert(v.begin(), nums[0]);
            res.push_back(v);
        }

        swap(nums[0], nums[i]);
    }
    return res;
}

void checkQueue1() {
    // if the queue can enqueue elements at head and tail, but dequeue elements only at head
    // check which of the sequences in combination() can be generated by the queue
    vector<int> nums = {1, 2, 3, 4};
    vector<vector<int>> res = fullPermulation(move(nums)); // the full permutation of nums

    for (auto &seq : res) {
        vector<int> queue_simu;
        unsigned i = 0, j = 0;
        while (true) {
            if (queue_simu.empty()) { // if the queue is empty, enqueue nums[j] directly
                queue_simu.push_back(nums[j]);
            } else {
                // think about the way to enqueue nums[j] to the queue:
                // 2 ways: enqueue at head or enqueue at tail
                // you just need to care about the relative position of nums[j] and 
                // any element in the queue (1 ele is enough, cause you just need to
                // care about the ways to enqueue nums[j]. If you want to think all of them, 
                // you can break the loop as soon as you find the conflict)
                int ele = queue_simu[0];
                int pos_ele = -1, pos_j = -1; // find the pos of tmp and nums[j] in seq
                for (unsigned k = 0; k < seq.size(); k++) {
                    if (seq[k] == ele) pos_ele = k;
                    if (seq[k] == nums[j]) pos_j = k;
                }
                if (pos_ele > pos_j) {
                    queue_simu.insert(queue_simu.begin(), nums[j]);
                } else {
                    queue_simu.push_back(nums[j]);
                }
            }

            while (!queue_simu.empty()) {
                if (queue_simu[0] == seq[i]) {
                    queue_simu.erase(queue_simu.begin());
                    i += 1;
                } else {
                    break;
                }
            }

            j += 1;
            if (i == seq.size() || j == nums.size()) break;
        }

        if (i == seq.size()) {
            cout << "seq: ";
            for (auto &i : seq) cout << i << " ";
            cout << "can be generated by the queue" << endl;
        } else {
            cout << "seq: ";
            for (auto &i : seq) cout << i << " ";
            cout << "can not be generated by the queue" << endl;
        }
    }
}


void checkQueue2() {
    // if the queue can dequeue elements at head and tail, but enqueue elements only at tail
    // check which of the sequences in combination() can be generated by the queue
    vector<int> nums = {1, 2, 3, 4};
    vector<vector<int>> res = fullPermulation(move(nums)); // the full permutation of nums

    // this will be much easier than checkQueue1()
    for (auto & seq : res) {
        vector<int> queue_simu;
        unsigned i = 0, j = 0; 
        while (true) {
            if (seq[i] != nums[j]) 
                queue_simu.push_back(nums[j]);
            else 
                i += 1;
            
            while (!queue_simu.empty()) {
                if (queue_simu[0] == seq[i]) {
                    queue_simu.erase(queue_simu.begin());
                    i += 1;
                } else if (queue_simu[queue_simu.size() - 1] == seq[i]) {
                    queue_simu.pop_back();
                    i += 1;
                } else {
                    break;
                }
            }

            j += 1;
            if (i == seq.size() || j == nums.size()) break;
        }

        if (i == seq.size()) {
            cout << "seq: ";
            for (auto &i : seq) cout << i << " ";
            cout << "can be generated by the queue" << endl;
        } else {
            cout << "seq: ";
            for (auto &i : seq) cout << i << " ";
            cout << "can not be generated by the queue" << endl;
        }
    }
}

int main() {

    checkQueue2();

    return 0;
}