//指针指向 变量 数组 函数
//名称含义 变量 var 数组 arr  多维数组 mul  函数 fun
//运算符 & 取址运算符  * 指针运算符  []变址运算符  -> 间接引用运算符(用于指向结构体变量的指针)

//建议使用断点调试的方式进行调试阅读
#include<stdio.h>
#define N 10
int symble(int x,char y)
{
    return 0;
}
int main()
{
    //指向变量 指针最简单的用法
    int var=1;
    int *p_var=&var;
    //首先定义一个变量，然后定义一个与之类型相对应的指针 用取址符&取得变量的地址，并再将该地址赋值给指针变量 之后，该指针便指向了该变量的地址，并可通过指针运算符*读取该地址的内容，该内容既是该指针所指向的变量(也称为变量的间接调用)
    /*这里要注意几个点 
    1.该指针的基类型为(int *) 而不是(int)  (p_var)才是该指针的名称 而不是(*p_var)
    2.在这里说的“地址”并不只是单纯地表示该变量储存的位置 同时还表示该变量的类型 即是说该地址包含了“位置与类型”两个内容
    3.指针变量同其他变量一样 其值是可以改变的 你可以在重新对其赋值使它指向另一同类型变量
    */
    printf("该指针所指向的地址中的内容：为：%d\n该指针所指向的地址为：%p\n\n",*p_var,p_var);//%p为 输出指针所指向的地址 的输出格式
    

    //指向一维数组
    int arr[N]={0,1};
    int *p_arr1=arr;//这里值得注意的是 一维数组的名称（在这里是arr）代表的既是该数组第一个元素的地址（在这里是arr[0]）的地址，你可以通过这种写法令指针指向该一维数组
    int *p_arr2=&arr[0];//上面的写法与这种写法是等价的 两者含义相同
    //在这里 指针p_arr1与p_arr2的基类型仍为(int *)型 它们指向的实际上仍为单个整型变量，只不过这个整型变量包含在一个整型数组里罢了
    printf("内容：%d\n地址：%p\n\n",*p_arr1,p_arr1);
    printf("内容：%d\n地址：%p\n\n",*p_arr2,p_arr2);
    
    //我想你已经知道 在c语言中数组中的元素是连续存放的 你可以通过指针加上或减去一个常数n的方式来令指针指向后或前n个位置的数组元素(注意不要越界)
    printf("内容：%d\n地址：%p\n\n",*(p_arr1+1),p_arr1+1);
    printf("内容：%d\n地址：%p\n\n",*(p_arr2+1),p_arr2+1);
    printf("%d\n\n",&arr[1]-&arr[0]);//指向同一数组内的元素的指针之间相减是有意义的，其结果即为两个指针所指向的元素储存位置之间的距离   但要注意，指针之间的加法运算是无意义的
    
    //字符型指针的用法有点特殊，这里单独把它拉出来讲
    char *p_str="I am Lost,Because I am In Double_Duck University!!!";
    //可以看见，这里直接令一个字符型指针=一个字符串的赋值方式是合法的
    //但需要注意
    //1.该赋值语句的含义并不是直接让指针p_str指向整个字符串  实际上，在执行该语句时编译器会先为该字符串分配一个地址，将该字符串以一个无名字符数组的形式储存在该地址内，然后再使该指针指向该数组的第一个元素
    /*2(超纲).由于该字符串是以一个无名数组的形式进行储存，除了用地址间接引用外你将无法通过其它方式对该地址的内容进行引用，这也就意味着，如果你在后续的程序中直接令p_str指针指向其它地址，你将再无法找回该无名地址，但是无名地址内储存的字符数组仍然存在，我们称这些无法引用的内容为程序垃圾。
        程序垃圾有可能会影响到程序后续的执行，因此在编写程序的时候一定要避免这样的垃圾的产生(清扫垃圾的方法也是存在的，但这将涉及到另一个头文件的内容，你有兴趣的话可以问我，现阶段你只需要注意不要随便用这样的指针指向其它地址就好)*/
    printf("内容:%s\n地址:%p\n\n",p_str,p_str);
    printf("内容:%s\n地址:%p\n\n",p_str+10,p_str+10);//通过指针的位移运算也可看出该字符串是以字符数组的形式进行储存的
    
    //同时，这里介绍字符指针一个比较灵活的用法
    //事实上，我们使用的printf函数中" "及其内容指的就是一个字符串，其调用原理与指针指向字符串相似，因此你可以通过用一个指向字符串的字符型指针来代替printf()中的""及其内容
    char *format1="内容:%s\n地址:%p\n\n";
    printf(format1,p_str);//scanf同理

    //为了偷懒，之后我的输出格式都以format的格式来表示

    //指针数组，其性质与一般的数组性质基本相同，只是其元素换成了指针而已（超纲）
    char *str[]={"have","a","good","day"};//指针数组可以用在很多方面，这里仅介绍其中的一种，字符型指针数组
    printf("%s\n%s\n\n",str[2],str[3]);
    //字符型指针数组十分有用，具体我会给你上实例
    
    char *format2="内容:%d\n地址:%p\n\n";


    //然后就到了最难理解的部分，指向多维数组的指针(超纲)
    
    //首先要注意的是，对于多维数组而言，其数组名代表的将不再单纯是一个变量的地址
    //可以这么去理解：首先 我定义了一个数组mul，它里面的元素都是普通的变量时，它便是我们熟悉的一维数组，此时它的数组名"mul"代表的即为其第一个元素（即mul[0]）的地址
    //那么，如果现在，mul中的元素不再是普通的变量，而是一个数组呢？此时，它的数组名"mul"代表的仍然是第一个元素的地址，但相对与mul而言，它的第一个元素不再是单纯的一个变量，而是一个包含了多个变量的数组,它的数组名为mul[0]
    //也就是说 此时mul代表的地址是 一个数组mul[0]的地址 而不是mul[0][0]的地址

    //那么？假设我定义了一个三维数组mul[N][N][N]呢？此时，相对于数组mul来说，它的第一个元素是一个二维数组，它的数组名为mul[0],而对于这个二维数组来说，它的第一个元素又是一个一维数组，它的数组名为mul[0][0]
    //于是对于三维数组mul来说，其数组名mul代表的是二维数组mul[0]的地址,而对于二维数组mul[0]来说，它的数组名代表的则是一维数组mul[0][0]的地址,而对于一维数组mul[0][0]来说，它的数组名代表的则是一个变量mul[0][0][0]的地址
    //对于更高维的数组来说也是同样

    //明白了这个，我们来看看应该如何用指针指向一个多维数组
    int mul[N][N]={{0,1},{2}};

    int (*p_mul1)[N]=mul;//由上述可知，mul数组名所对应的是mul[0]数组的地址，要想直接用数组名mul进行赋值，我们也许相应地定义一个能够指向该一维数组的指针 此时，该指针的基类型应为 (int*)[N] 意为一个指向一维数组的整型指针
    printf(format2,**p_mul1,p_mul1);//注意此处 若用*对p_mul1取值，你得到的将会是一个一维数组的地址 若你想要输出一个具体元素的值，你还需要再加一个* 如此处输出的即为mul[0][0]的值

    int *p_mul2=mul[0];//而对于一维数组的数组名，其代表的便是元素mul[0][0]的地址，其用法与一般的一维数组相同
    printf(format2,*p_mul2,p_mul2);
    //可以看到 p_mul1 与 p_mul2 用%p输出后的值是相同的，但这并不意味着两地址等价 前面已经提过，一个地址包括了位置与类型两个信息 在这里p_mul1与p_mul2所指向的位置值虽然是相同的，但是他们所指向的地址的基类型并不相同
    //对于p_mul1来说 它指向的是mul[0]的开头的地址；而对于p_mul2来说 它指向的是mul[0][0]的地址 两者所指位置相同 但p_mul1所指的是一个一维数组 p_mul2所指的是一个具体的整型元素 两者的基类型并不相同 

    //然后要注意两个不同基类型的指针在加上一个常数其含义的区别
    printf(format2,**(p_mul1+1),p_mul1+1);//对于指向一维数组mul[0]的指针p_mul1来说，令其加上1后它将会指向下一个一维数组mul[1] 因此在这里输出的是mul[1][0]的值
    printf(format2,*(p_mul2+1),p_mul2+1);//而对于指向了mul[0][0]的指针p_mul2来说，令其加上1后他将会指向一维数组mul[0]中的下一个元素 也既是mul[0][2]
    
    
    //指向函数的指针（超纲）
    //指向函数的指针一般只会用于需要书写多个自定义函数的大项目中，这里只需掌握指向函数的指针的基类型即可
    int (*p_fun)(int,char)=symble;//此处定义的指针的基类型为 (int*)(int,char) 其中前半部分需要与函数的类型相对应，若为空函数则对应地写为(void*) 后半部分则应与函数中的参量的类型相对应
    printf("地址:%p\n\n",p_fun);

    //有关指针的定义大概就是这么多 在这里我还有一个指向结构体变量的指针没有讲 但这个是涉及到十分后面的内容 属于大超纲 如果你有兴趣了解的话随时叫我 而指针作为参数时形参的定义格式我会放在另一个文件中
    return 0;
}