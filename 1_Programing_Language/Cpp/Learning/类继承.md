# 类继承

通过这种方法能够让我们从已有的类派生出新的类，而**派生类**继承了原有类（称为**基类**）的特征，包括方法

## 继承的功能

1. 可以在已有类的基础上添加功能
2. 可以给类添加数据
3. 可以修改类方法的行为

## 基类

从一个类派生出另一个类时，原始类称为基类，继承类称为派生类

## 派生一个类

### 公有派生

1. 派生类对象存储了基类的数据成员（派生类继承了基类的实现）
2. 派生类对象可以使用基类的方法（派生类继承了基类的接口）
3. 派生类需要自己的构造函数
4. 派生类可以根据需要添加额外的数据成员和成员函数

```cpp
class Classy {
    // ...
}

class Derived : public Classy {
    // ...
}

// 上述声明表明 Classy 是一个公有基类，这被称为公有派生
// 使用公有派生，基类的公有成员将成为派生类的公有成员
// 基类的私有部分也将成为派生类的一部分，但只能通过基类的公有和保护方法访问
```

#### is-a关系

公有继承将会建立一种is-a关系，即派生类对象也是一个基类对象，可以对基类对象执行的任何操作，也可以对派生类对象执行

<!-- is-a关系通常是不可逆的 -->

<!-- 例如 fruit 可以派生出 banana， 其中 banana is a kind of fruit -->

#### has-a关系

公有继承不建立has-a关系

<!-- 例如 breakfast has a banana -->

#### is-like-a关系

公有继承不建立 is-like-a关系

#### is-implemented-as-a关系

公有继承不建立 is-implemented-as-a关系（作为……来实现）

#### uses-a关系

公有继承不建立 uses-a关系

#### 多态公有继承

同一个方法在派生类和基类中的行为是不同的。即是说方法的行为应取决于调用该方法的对象。这种较复杂的行为称为多态（具有多种形态），即同一个方法的行为随上下文而异。

实现多态的两种重要机制：
1. 在派生类中重新定义基类的方法
2. 使用虚方法

<!-- 如果要在派生类中重新定义基类的方法，通常应将基类方法声明为虚的。这样，程序将根据对象类型而不是引用或指针的类型来选择方法版本。为基类声明一个虚析构函数也是一种惯例 -->

### 构造函数访问权限

派生类不能直接访问基类的私有成员，而必须通过基类方法进行访问

创建派生对象时，程序首先创建基类对象。从概念上来说，这意味着基类对象应当在程序进入派生类构造函数之前被创建。C++使用成员初始化来完成这种工作。

创建派生类对象时，程序首先调用基类构造函数，然后再调用派生类构造函数。基类构造函数负责初始化继承的数据成员；派生类构造函数主要用于初始化新增的数据成员。派生类的构造函数总是调用一个基类构造函数。可以使用初始化列表语法指明要使用的基类构造函数，否则将使用默认的基类构造函数。

派生类构造函数的要点如下：
1. 首先创建基类对象
2. 派生类构造函数应通过成员初始化列表将基类信息传递给基类构造函数
3. 派生类构造函数应初始化派生类新增的数据成员

```cpp
// 成员初始化列表
derived::derived(type1 x, type2 y) : base(x, y) { // initializer list
    // ...
}
// 其中 derived是派生类，base是基类，x 和 y 是基类构造函数使用的变量。
// 如果没有在成员初始化列表中提供基类构造函数，程序将使用默认的基类构造函数。（成员初始化列表只能用于构造函数）
```

当派生类对象过期时，程序将首先调用派生类析构函数，然后调用基类析构函数。


[Practice_42](../Practice/Practice_42.cpp)


### 派生类和基类之间的特殊关系

1. 派生类对象可以使用基类方法
2. 基类指针可以在不进行显示类型转换的情况下指向派生类对象；基类引用可以在不进行显示类型转换的情况下引用派生类对象。然而，基类的指针或引用只能用于调用基类方法（通常，C++要求引用和指针类型与赋给的类型匹配，但这一规则对于继承来说是例外，然而，这种例外只是单向的）


## 静态联编 和 动态联编

将源代码中的函数调用解释为执行特定的函数代码块被称为函数名联编（binding）。
在编译过程中进行联编被称为静态联编（static binding），又称早期联编（early binding）。
在程序运行时进行联编被称为动态联编（dynamic binding），又称晚期联编（late binding）。

### 指针和引用类型的兼容性

将派生类引用或指针转换为基类引用或指针被称为向上强制转换（upcasting），这是公有继承不需要进行显示类型转换。这规则是is-a关系的一部分

---

将基类指针或引用转换为派生类指针或引用称为向下强制转换（downcasting）。如果不使用显式类型转换，则向下强制转换是不允许的。原因是is-a关系通常是不可逆的。

### 虚成员和动态联编

编译器对非虚方法使用静态联编，对于虚方法使用动态联编。

<!-- 如果要在派生类中重新定义基类的方法，则将它设置为虚方法；否则设置为非虚方法 -->


## 访问控制：protected

关键字protected与private相似，在类外只能用公有类成员来访问protected部分中的类成员。

派生类成员可以直接访问基类的保护成员，但不能访问基类的私有成员

<!-- 对于外部世界来说，保护成员的行为与私有成员相似；但对于派生类来说，保护成员的行为与公有成员相似 -->

<!-- 最好对类数据成员采用私有访问控制，不要使用保护访问控制；同时通过基类方法是派生类能够访问基类数据 -->

[Practice_45](../Practice/Practice_45.cpp)

## 抽象基类

抽象基类（abstract base class， ABC）

要成为真正的ABC，必须至少包含一个纯虚函数。

ABC描述的是至少使用一个纯虚函数的接口，从ABC派生出的类将根据派生类的具体特征使用常规虚函数来实现这种接口

可以将ABC看作是一种必须实施的接口。ABC要求具体派生类覆盖其纯虚函数——迫使派生类遵循ABC设置的接口规则。
<!-- 这种模型在基于组件的编程模式中很常见 、，在这种情况下，使用ABC使组件设计人员能够制定“接口约定”，这样确保了从ABC派生的所有组件都至少支持ABC指定的功能 -->

[Practice_44](../Practice/Practice_44.cpp)


## 继承和动态内存分布

### 第一种情况：派生类不使用new

这种情况下，为派生类定义显式析构函数、复制构造函数和赋值运算符并不是必须的

### 第二种情况：派生类使用new

这种情况下，必须为派生类定义显式析构函数、复制构造函数和赋值运算符
