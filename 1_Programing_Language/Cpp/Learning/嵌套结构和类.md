# 嵌套结构和类

在类声明中声明的结构、类或枚举被称为是被嵌套在类中，其作用域为整个类。这种声明不会创建数据对象，而是指定了可以在类中使用的类型。如果声明是在类中的私有部分进行的，则只能在这个类使用被声明的类型；如果声明是在公有部分进行的，则可以从类的外部通过作用域解析运算符使用被声明的类型

## 成员初始化列表的语法

如果 Classy 是一个类， 而 mem1、mem2 和 mem3 都是这个类的数据成员，则类构造函数可以使用如下的语法来初始化数据成员：
```cpp
Classy:: Classy(int n, int m) : mem1(n), mem2(m), mem3(n + m) {
    // ...
}
// 注意：
// 这种格式只能用于构造函数
// 必须用这种格式来初始化非静态 const 数据成员（C++11前）
// 必须用这种格式来初始化引用数据成员
// 数据成员被初始化的顺序与它们出现在类声明中的顺序相同，与初始化器中的排序顺序无关、

// 成员初始化列表使用的括号方式也可以用于常规初始化
// 也即是说你也可以 int num(11);
```

## C++11 的类内初始化

```cpp
class Classy {
    int mem1 = 10;
    const int mem2 = 20;
    // ...
};
// 这与在构造函数中使用成员初始化列表等价
```


# 参考

https://www.cnblogs.com/ForFreeDom/archive/2012/09/10/2678826.html


## 概述

1. 可以在另一个类内部定义一个类，这样的类是**嵌套类**，也称为**嵌套类型**。嵌套类最常用于定义执行类，如第十六章的 QueueItem 类。
---
2. 嵌套类是**独立**的类，基本上与它们的外围类**不相关**，因此，外围类和嵌套类的对象是**互相独立**的。嵌套类型的对象不具备外围类所定义的成员，同样，外围类 的成员也不具备嵌套类所定义的成员。<!--（在分析时常常将它们作为两个分别定义的类来看）-->
---
3. 嵌套类的名字**在其外围类的作用域中可见**，但**在其他类作用域或定义外围类的作用域中不可见**。嵌套类的名字将不会与另一作用域中声明的名字冲突。
---
4. 嵌套类可以具有与非嵌套类相同种类的成员。像任何其他类一样，嵌套类使用访问标号控制对自己成员的访问。成员可以声明为 public、private 或 protected。**外围类对嵌套类的成员没有特殊访问权，并且嵌套类对其外围类的成员也没有特殊访问权。**
---
5. 嵌套类定义了其外围类中的一个类型成员。像任何其他成员一样，外围类决定对这个类型的访问。在外围类的 public 部分定义的嵌套类定义了可在任何地方使用的类型，在外围类的 protected 部分定义的嵌套类定义了只能由外围类、友元或派生类访问的类型，在外围类的 private 部分定义的嵌套类定义了只能被外围类或其友元访问的类型。


## 嵌套类的定义：

1. 在其类外部定义的嵌套类成员，必须定义在定义外围类的同一作用域中。在其类外部定义的嵌套类的成员，不能定义在外围类内部，嵌套类的成员不是外围类的成员。
---
2. 在外围类外部定义嵌套类

    a.外围类的外部定义类体，必须用外围类的名字限定嵌套类的名字。注意，我们仍然必须在外围类的定义体声明嵌套类。

    b.在类定义体外部定义的嵌套类的实际定义之前，该类是不完全类型，应用所有使用不完全类型的常规限制。但是对于模板来说没有这个限制.

    c、嵌套类静态成员定义：如果嵌套类声明了一个静态成员，它的定义也需要放在外层作用域中。



## 嵌套类的使用

1. 外围作用域的对象与其嵌套类型的对象之间没有联系：**嵌套类中的非静态函数具有隐含的 this 指针，指向嵌套类型的对象**。嵌套类型对象只包含嵌套类型的成员，不能使用 this 指针获取外围类的成员。同样，**外围类中的非静态成员函数也具有 this 指针，它指向外围类型的对象，该对象只具有外围类中定义的成员。**
---
2. 使用静态成员或其他类型的成员：**嵌套类可以直接引用外围类的静态成员、类型名和枚举成员**。当然，引用外围类作用域之外的类型名或静态成员，需要作用域确定操作符。



## 嵌套模板的实例化

1. 实例化外围类模板的时候，不会自动实例化类模板的嵌套类。像任何成员函数一样，只有当在需要完整类类型的情况下使用嵌套类本身的时候，才会实例化嵌套类。
---
2. 使 QueueItem 类成为类模板 Queue 的嵌套类并不改变 QueueItem 的实例化。只有在使用 QueueItem<int> 的时候——本例中，只有当 Queue<int> 类的成员函数中对 head 和 tail 解引用的时候，才实例化 Queue<int> 类。



## 嵌套类作用域中的名字查找

1. 对嵌套类中所用名字的名字查找在普通类的名字查找之前进行，现在唯一的区别是可能要查找一个或多个外围类作用域。
---
2. **当处理类成员声明的时候，所用的任意名字必须在使用之前出现**。当处理定义的时候，整个嵌套类和外围类均在作用域中。
