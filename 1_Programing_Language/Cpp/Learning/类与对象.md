# 类与对象

[toc]

## 特征
1. 封装
2. 继承
3. 多态

## 类

一种复杂的**数据类型**，它是将个体**属性类型**和与这些属性有关的**操作**封装在一起的集合体，因此，定义类就是定义一种新的数据类型
<!-- 相比起结构体而言多了操作函数 -->
<!-- 对象是类的实例化 -->

> 注意：定义时系统并**不为类分配存储空间**，所以不能对类的数据成员初始化

### 类的数据隐藏

类的⼀些属性可以设置为不被外界直接操作，所以这些数据
对外界来说是不可⻅性，外⾯只有**通过类的操作函数**才能操作类
的内部数据

### 类的定义

编译时进行创建（程序运行前）

```cpp
class Name/* 类型名 */
{
    private: /* 访问限定符，其后所列为私有成员 */
    // 私有数据和函数成员的声明或实现；
    public: /* 访问限定符，其后所列为公有成员 */
    // 公有数据和函数成员的声明或实现；
    protected:
    // 保护数据和函数成员的声明或实现；
};
```

#### 访问限定符

> public（公共的）
> private（私有的）
> protected（保护的）

1. 其中后两种说明的成员是不能从外部进⾏访问的。每种说
明符可在类体中使⽤多次。它们的**作⽤域**是从该说明符出现
开始到下⼀个说明符之前或类体结束之前结束

2. 若无访问说明符，系统将默认其为 private 成员

3. 访问说明符 private 和 protected 体现了类具有**封装性**，实现数据成员的**隐藏**特性

#### 成员函数

在类的定义中，引进了成员函数 (member function),也就是
说函数也成了类中的⼀部分。类把数据（事物的属性）和函数
（事物的⾏为——操作）（也称为⽅法）封装为⼀个整体

成员函数 可以直接使⽤ 类定义中的任⼀成员，可以处理
数据成员，也可调⽤函数成员。

调用成员函数时，它将使用被用来调用它的对象的数据成员

公有函数集定义了类的 接⼝（interface）（对外开放）

<!-- 所创建的每个新对象都有自己的存储空间，用于存储其内部变量和类成员；但同一个类的所有对象共享同一组方法，即每种方法只有一个副本 -->

```cpp
// 1. 一般较长的成员函数我们只在类定义时给出起原型，随后在外部给出其功能的具体定义

functionType className::memberFun (/* arguments */) {
    /* function */
}

// '::' 作用域运算符（scope resolution operator）,又称 范围运算符。 它指出该函数属于哪一个类的成员函数

// 2. 对于较短的成员函数，我们也可以直接在类里面进行定义，我们称这样的成员函数为内联成员函数
// 根据改写规则，在类声明中定义方法等同于用哦该原型替换内部的方法定义，然后在类声明后面将定义改写为内联函数

class className {
    private :
        dataType : Data;
    public :
        functionType funName(/* arguments */) {
            /* function */
        }
};
```

## 对象

### 对象是类的实例化

类只是一种数据类型，定义某个类只是声明了一种新的数据类型，告诉编译系统该数据类型的结构形式，此时计算机并没有为它分配内存，只有在定义对象后，系统才为该对象分配内存

### 对象的创建

1. 直接创建（静态创建）

创建于程序**编译时**（程序运行时）
```cpp
className obj1,obj2;
```
2. 动态创建

创建于程序**运行时**

### 内存中对象的空间布局

原则上，对象在内存中的存储形式和结构⼀样，同类的每个
对象都被分配⼀段能保存其所有成员的存储单位，但为了节省
内存，在创建对象时只为每个对象的数据成员分配内存，⽽成
员函数只是⼀次性存放在静态存储区中，为所有对象所共享
（因为代码指令都是⼀样的）

### 对象内的数据成员与函数成员的访问

1. 成员访问运算符 '.'
2. 指向运算符 '->'

### 对象数组

<!-- 字符串数组本质上也是对象数组 -->

```cpp
class Test {
    /*……*/
};
Test test[N];
```

### 对象指针

> 在建立对象时，编译系统会为每一个对象分配一定的存储空间，以存放其成员。对象空间的起始地址就是对象的指针。

```cpp
// 可以定义一个指针变量，用来存放对象的指针

class Test {
    // content
};
Test test(//arguments);
Test *p = test;
```

每个成员函数中都包含一个特殊的指针，该指针称为**this**，它是指向本类对象的指针（谁调用指向谁）

this指针是**隐式使用**的，它是作为参数被传递给成员函数的

也可以用 ***this** 表示**被调用的成员函数所在的对象**，即当前的对象

```cpp
// 我们所写
class className {
    private :
        dataType data;
    public :
        className(tData) {
            data = tData;
        }
        ~className() {/* blank */}
        void memberFun(void);
};
className :: memberFun(void) {
    cout << data << endl;
}
className test(testData);
test.memberFun();

// 经过C++编译系统处理
// 以下转变过程都是由编译系统自动实现的，当然，如有需要也可以显式地使用 this指针
class className {
    private :
        dataType data;
    public :
        className(tData) {
            data = tData;
        }
        ~className() {/* blank */}
        void memberFun(void);
};

className :: memberFun(className *this) { // 隐式转换
    cout << this -> data << endl;
}
className test(testData);
test.memberFun(&test); // 隐式转换
```

# 构造函数与析构函数

## 构造函数

每个对对象在创建的时候都会自动调用一个初始化函数，并且只能够调用一次，这样的函数称为**构造函数（constructor）**

### 构造函数的特征

1. **函数名与类名相同**
2. 构造函数**无函数返回类型说明**
3. 程序运行时，当新的对象被建立，该对象所属的类的构造函数自动被调用，在该对象的生存期中也**只调用这一次**
4. 构造函数可以**重载**。类定义中可以有多个构造函数，它们由不同的参数表区分，系统在自动调用时按一般函数重载的规则**选一个**进行执行
5. 构造函数可以在**类中定义**，也可以在**类外定义**
6. 如果类说明中没有给出构造函数，则C++编译器自动给出一个**缺省**的构造函数

    但只要我们定义了⼀个构造函数，系统就不会⾃动⽣成缺
    省的构造函数。缺省的构造函数，也可以由程序员⾃⼰来编，
    只要构造函数是⽆参的或者只要各参数均有缺省值的，C++ 编
    译器都认为是缺省的构造函数

    如果对象的数据成员 **全为公有的**，在缺省构造函数⽅式下，
    也可以在对象名后加“=”加“{}”，在花括号中顺序填⼊全体数据
    成员的**初始值**。

<!-- 缺省：默认 -->


```cpp

class className {
    private :
        dataType1 Data1;
        dataType2 Data2;
        dataType3 Data3;
    public :
        className(dataType1 data1, dataType2 data2, dataType3 data3) {
            Data1 = data1; Data2 = data2; Data3 = data3; // 具体情况具体写
            cout << "constructor work" << endl;
        }
};

// 显式调用构造函数
className A = className(/*parameter list*/);

// 隐式调用
className B(/*parameter list*/);

// 在C++11中,也可将列表初始化的语法用于类
className C = {/*parameter list*/};
// or
// className C {/*parameter list*/};

// 构造函数不仅仅可以用于初始化新对象
A = className(/*parameter list*/); // A 对象已经存在，因此这条语句不是对A对象进行初始化，而是通过让构造程序创建一个新的临时对啊ing，然后将其内容复制给 A。随后程序将调用析构函数，以删除该临时对象
```
[Practice_28](../Practice/Practice_28.cpp)




## 析构函数

当⼀个对象定义时，C++ ⾃动调⽤构造函数建⽴该对象并进
⾏初始化，那么当⼀个对象的⽣命周期结束时，C++ 也会⾃动调
⽤⼀个函数 **注销** 该对象并进⾏善后⼯作，这个特殊的成员函数即 **析构函数（destructor）**

### 析构函数的特征

1. **析构函数名与类名相同**，但在前⾯加上字符 **~**，如
~Student（）
2. 析构函数 **⽆函数返回类型**，与构造函数在这⽅⾯是⼀样的。但析构函数**不带任何参数**。
3. ⼀个类有**只有⼀个**析构函数，析构函数**可以缺省**。
4. 对象**注销时**，系统⾃动调⽤析构函数。

```cpp
~className() {
    cout << "destructor work" << endl;
}
```

### 复制构造函数

使用同一类的另一个对象来初始化该对象，这个拷贝过程只需要拷贝数据成员，这时使用的构造函数称为 **复制构造函数（Copy Constructor）**

```cpp
// 在类外部定义
className::className(const className &objName) {
    /* 复制过程 */
}

// 在类内部定义
class className {
    public:
        className(const className &objName) {
            /* copy */
        }
};

// 同类对象之间可以直接用'='进行拷贝，在默认情况下，将一个对象赋给同类型的另一个对象时，C++将源对象的每个数据成员的内容复制到目标对象中相应的数据成员中

// 注意复制构造函数的参数采用的是引用的方式，如果把一个真实的类对象作为参数传递到复制构造 函数，会引起无穷递归

// 在类定义中如果没有显式给出复制构造函数时，并不是不用复制构造函数，而是由系统自动调用缺省的复制构造函数

```
[为什么复制构造函数的参数一定要为引用值](Practice_39.cpp)

复制构造函数的另一个使用方面：

1. 当函数的形参是类的对象，调用函数时，进行形参与实参结合时使用
2. 当函数的返回值时类的对象，建立一个临时对象用以接受返回的对象<!-- 局部对象在离开建立它的函数时就消亡了，所以不能够直接返回的局部对象，所以在这种情况时，编译系统会在调用函数的表达式中创建一个无名临时对象，该临时对象的生存周期只在函数掉用处的表达式中。所谓return对象，实际上是调用复制构造函数把该对象的值拷贝入临时对象中 -->

### 构造函数和析构函数的调用

对于不同作用域的对象类型，构造函数和析构函数的调用如下：

1. 对全局定义的对象，当程序进入入口函数 main之前对象就已经定义，这时要调用构造函数。整个程序结束时调用析构函数
2. 对于局部定义的对象，每当程序控制流到达该对象定义处时，调用构造函数。当程序控制走出该局部域时，调用析构函数
3. 对于静态局部定义的对象，当程序控制首次到达该对象时调用构造函数，当整个程序结束时调用析构函数

# 成员对象

在定义类的对象时不仅要对对象中的普通数据成员进行初始化，也要对对象成员进行初始化

```cpp
// C++中对含对象成员的类对象的构造函数的格式
// 类名::构造函数名(参数总表):
//     对象成员1(参数表1（表中的参数来自于参数总表）),
//     对象成员2(参数表2),
//     ……
//     对象成员n(参数表n)
// {普通数据成员初始化}

// 实例见Practice_3

// 对于不含对象成员的类对象的初始化，也可以套⽤以上的
// 格式，把部分只需要直接赋初值的变量初始化写在冒号的右边

// 构造函数名(参数表):变量1(初值1),……,变量n(初值n)
// { // 见 Practice_4
//     ……
// }
```

# 字符串类

> string是在C++标准库中声明的一个字符串类,每一个字符串变量都是string类的一个对象

## 字符串变量的定义与引用

```cpp
string str;
str = "Hello World!";
```

## 字符串变量的输入和输出

```cpp
string str;
cin >> str;
cout << str << endl;
```

## 字符串变量的运算

1. 字符串复制可直接采用赋值的方式
2. 字符串连接可直接使用加号
3. 字符串比较可直接使用关系运算符

```cpp
// example
#include<string>

using namespace std;

int main() {
    string str1 = "Hello World";
    string str2 = str1;
    string str3 = "!";
    cout << str1 + str3 << endl;
    cout << str1 > str3 << endl;
    return 0;
}
```

## 字符串数组

```cpp
string str[5] = {"Hello"," ","World","!"};
```

# 友元

<!-- 类具有封装性，类中的私有成员或保护成员数据⼀般只能
通过该类中的成员函数才能访问，⽽程序中其他函数是⽆法直
接访问私有数据的。类的封装机制带来的好处是明显的，但若
绝对不允许外部函数访问类的私有成员的话，确实也有很多不
便之处，如果频繁地通过成员函数来访问的话，过多的参数传
递、类型检查，会影响程序的运⾏效率。 -->

友元（friend）函数，允许在类外的普通函数访问该类中的任何成员

<!-- 注意：只有在类声明中的原型才能够使用friend关键字。除非函数定义也是原型，否则不能再函数定义中使用该关键字 -->

## 使用情景

1. 运算符重载的某些场合需要使用友元
2. 两个类需要共享数据的时候


## 使用友元函数的优缺点

优点：能够提高效率，使表达更为简单清晰

缺点：友元函数破坏了封装机制，因此除非不得已的情况尽量不使用友元函数

## 普通非类成员函数作为友元

```cpp
friend 类型说明 友元函数名 (参数表);
// 例见 Practice_6.cpp
```

[Practice_6](../Practice/Practice_6.cpp)

## 类的成员函数作为友元

```cpp
friend funType className::friendFun(/**/);
// 例见 Practice_7.cpp 与 Practice_8.cpp
```

[Practice_7](Practice_7.cpp)

## 使用友元函数的注意点

1. 友元函数是一种声明在类体内的普通函数，不是类的成员函数，在函数体中访问对象的成员，必须用对象名加运算符“.”加对象成员名。但友元函数可以访问类中的**所有成员**，一般函数只能访问类中的公有成员
---
2. 友元函数声明**不受类中的访问权限关键字限制**，可以把它放在类的公有、私有、保护部分，但结果一样
---
3. 一个类的成员函数做另一个类的友元函数时，必须先定义它 <!-- 可参考Practice_7 & 8 -->


## 类作为友元

```cpp
// 见 Practice_9.cpp
class A {
    、、、
    friend class B; // 声明 B 作为 A 的友元类
};
```

[Practice_9](Practice_9.cpp)

## 使用友元类的注意事项

1. 友元关系是单向的
2. 友元关系不具有传递性

# 动态内存分配

通常定义变量（或对象），编译器在 编译时 都可以根据该变量（或对象）的类型知道所需内存空间的⼤⼩为他们分配确定的存储空间。这种内存分配称为 **静态存储分配**

---

有些操作只有在程序运⾏时才能确定，这样编译器在编译时就⽆法为他们预定存储空间，只能在程序运⾏时，系统根据运⾏时的要求进⾏内存分配，这种⽅法称为 **动态存储分配**。所有动态存储分配都在堆区中进⾏。

<!-- 动态存储区，即 **堆（heap）** 或 **自由存储区** -->

## new运算符

调用new运算符将会 **返回** 一个指向所分配类型变量（对象）的**指针** 。对所创建的变量或对象，都是通过该指针来间接操作的，而 动态创建的对象本身没有名字

## 堆内存的分配与释放

    当程序运⾏到需要⼀个动态分配的变量或对象时，必须向系
统 **申请取得** 堆中的⼀块所需⼤⼩的存贮空间，⽤于存贮该变量
或对象。当不再使⽤该变量或对象时，也就是它的⽣命结束时，
要 **显式释放** 它所占⽤的存贮空间，这样系统就能对该堆空间进
⾏再次分配，做到重复使⽤有限的资源。

    在 C++中，申请和释放堆中分配的存贮空间，分别使⽤
**new** 和 **delete** 的两个运算符来完成，其使⽤的格式如下：

```cpp
pointerName = new dataType(/* initial value */);
delete pointerName;
```

一般定义变量和对象时要用标识符命名，称**命名对象**，而动态的称**无名对象**。堆区时不会自动再分配时做初始化的，所以必须用初始化式（initializer）来**显式初始化**、

```cpp
// example

// initialization
int *pi = new int(0);

// deallocation
delete pi;
// 注意：动态内存释放（dynamic memory deallocation）并不意味着指针 pi被撤销，它本身仍然存在，该指针所占的内存空间并未释放

// 注意：只能用delete来释放用new分配的内存。然而，对空指针使用delete是安全的
```

## 数组的动态分配

```cpp
pointerName = new type[/* expression */];

// 下标表达式不是必须为常量表达式，它可以在运行时确定
// 不可对动态数组进行初始化，系统只会调用缺省的构造函数

delete [] pointerName;

// 若 delete 语句中少了⽅括号，因编译器认为该指针是指向数组第⼀个元素的指针，
// 会产⽣ 回收不彻底 的问题（只回收了第⼀个元素所占空间），
// 加了⽅括号后就转化为指向数组的指针，回收整个数组。
// delete []的⽅括号中 不需要 填 数组元素个数，系统⾃知。即使写了，编译器也忽略。

```

## 动态内存分配使用的几个问题


1. 动态分配失败。返回⼀个**空指针（NULL）**，表示发⽣了异常，堆资源不⾜，分配失败。
---
2. 指针删除与堆空间释放。删除⼀个指针 p（delete p;）实际意思是删除了 p **所指的⽬标**（变量或对象等），释放了它所占的堆空间，⽽不是删除ｐ本身，释放堆空间后，ｐ 成了**空悬指针**。
---
3. 内存泄漏（memory leak）和重复释放。new 与 delete 是配对使⽤的，如果 new 返回的指针值丢失，则所分配的堆空间⽆法回收，称**内存泄漏**，同⼀空间重复释放也是危险的，因为 该空间可能已另分配，
---
4. 动态分配的变量或对象的⽣命期。⽆名对象的⽣命期并不依赖于建⽴它的作⽤域，⽐如在函数中建⽴的动态对象在函数返回后仍可使⽤。我们也称堆空间为**自由空间**（free store）就是这个原因。但必须记住释放该对象所占堆空间，并**只能释放⼀次**，在函数内建⽴，⽽在函数外释放是⼀件很容易失控的事，往往会容易出错。

## 在构造函数中使用 new 时应该注意的事项

1. 如果在构造函数中使用 new 初始化对象的指针成员，则应该在析构函数中使用 delete
2. new 和 delete 必须相互兼容。new 对应于 delete，new[] 对应于 delete[]
3. 如果有多个构造函数，则必须以相同的方式使用 new，要么都带中括号，要么都不带。因为只有一个析构函数，所有的构造函数都必须与它兼容。然而，可以在一个析构函数中使用 new 初始化指针，而在另一个函数中将指针初始化为空，这是因为 delete 可以用于空指针

## 堆对象与构造函数

<!-- 基于堆对象的链表结构见 Practice_11.cpp -->
[Practice_11](Practice_11.cpp)


```cpp
// 通过 new 建立的对象需要调用构造函数，通过 delete 删除对象也要调用析构函数

className *pc; // 定义一个类的指针
pc = new className(); // 分配堆空间，构造一个无名的对象并调用构造函数

// new 后面的类类型也可以有参数，这些参数即是构造函数的参数

delete pc; // 先析构，然后释放内存
```

### 堆对象的生命周期

堆对象的生命周期并不依赖于建立它的作用域，除非程序结束，堆对象（无名对象）的生命周期不会会到期，并且需要显式调用 delete 语句析构堆对象（C++自动调用其析构函数）



# 浅拷贝和深拷贝

## 浅拷贝

**缺省拷贝构造函数**，可用一个类对象初始化另一个类对象，称为缺省的**按成员拷贝**，即**浅拷贝**

## 深拷贝

如果类中有⼀个数据成员为指针，该类的⼀个对象 obj1 中的这个指针 p 指向了动态分配的⼀个堆对象如果⽤ obj1 按成员拷⻉给另⼀个对象 obj2，这时 obj2.p 也指向同⼀个堆对象。这就会发⽣**数据交叉**，并当析构时，发⽣内存⼆次释放的问题。

这时就要重新定义拷⻉的构造函数，
给每个对象指针 p 独⽴分配⼀个堆对象，
称**深拷⻉**。

**这时先拷贝对象主体，再为 obj2 分配⼀个堆对象最后⽤ obj1 的堆对象拷⻉ obj2 的堆对象**

**定义拷贝（copy structor）**和**拷贝赋值操作符（copy Assignment Operator）**实现深拷贝

[Practice_15](./Practice_15_simple_deep_colone.cpp)
[运算符](%E8%BF%90%E7%AE%97%E7%AC%A6.md)
<!-- 见 Practice_15.cpp 与 运算符.md -->



# 链表与栈

## 栈（Stack）

<!-- 又称作 后进先出的线性表（LIFO: last in first out） -->

### 栈的定义

只允许在表的一端进行插入和删除的线性表

栈占用一段**连续**的内存空间，有两个端点，**允许进行插入和删除的一端称为栈顶（top），而另一端固定的叫栈底（bottom）**

### 栈的应用

> push 压入或进栈
> pop 弹出或出栈

### 栈类的数据定义

<!-- 见 Practice_16 -->


# 静态成员

<!-- 在有些应用中，希望程序中若干个同类的对象共享某个数据，这时候可以将共享数据成员在类中用关键字 **static** 修饰为 **静态类成员（static class member）**。 类的静态成员为其所有成员共享，不管有多少对象，静态成员只有一份存于公共内存中。 -->

在类定义中，用关键字 **static** 修饰的数据成员为**静态数据成员**。而该静态数据的存储空间是在编译时分配的，在定义对象时不再为静态成员分配空间。

静态数据实际上是**该类所有对象所共有的**，它更像在⾯向
过程程序设计时的全局变量，可提供同⼀类的所有对象之间信
息交换的捷径，正因为静态数据成员不属于类的某⼀特定对象，
⽽是 **属于整个类** 的，所以访问使⽤时可⽤以下格式：

```cpp
className :: staticClassMember
```

静态数据的初始化是在类外进行的

```cpp
dataType className :: staticClassMember = initialValue
// 对静态成员数据的定义性说明在文件作用域中只能实行一次

// C++静态数据成员缺省值为 ‘0’
```

<!-- 例见 Practice_17.cpp -->

## 静态成员函数

[Practice_17](Practice_17.cpp)

```cpp
// 静态成员函数基本相当于：一个带有命名空间的全局函数

// 静态函数与类的实例无关，只跟类有关，不需要this指针

// 因为静态成员函数独立于具体对象存在，所以一般使用静态成员函数来访问静态数据成员，若需要访问非静态数据成员，需要通过对象名进行访问

// 如果静态成员函数在类定义之外定义，则不能在定义是再加 static， 因为 static 不属于数据类型组成部分，这一点与友元函数相似

class className {
    static void function(void);
}

className :: function(void) {

}

// 见 Practice_17.cpp
```

# 类的作用域

类定义的花括号之间区域叫做 **类作⽤域**，在类中说明 的
成员变量，其可⻅性在该类域内。类域是介于⽂件域和函数域
之间的作⽤域，类体内可以定义函数，因此类域⽐函数域⼤，
⼀个⽂件可以包含若⼲的类，所以类域⽐⽂件域⼩。

## 嵌套类

在一个类中定义的类称为嵌套类，包含嵌套类的类称为外围类

定义嵌套类是为了隐藏类名，限制该类创建对象的范围，从而减少全局标识符，提高类的抽象能力

```cpp
class Outer {
    private :
     /* blank */
    public :
        class Inner {
            private :
                dataType data;
            public :
                /* blank */
        };
};
```

### 说明

1. 从作⽤域⻆度来看，嵌套类被隐藏在外围类中，所以该类名只能在外围类中使⽤，如果在外围类作⽤域外使⽤，则需加名字限定

---

2. 从访问权限⻆度来看，嵌套类名和外围类的成员名具有相同的访问权限，⼀般设置嵌套类为 public

---

3. 从嵌套类和外围类的关系⻆度来看，嵌套类的成员不是外围类的成员，嵌套类中的成员函数不能访问外围类中的成员，反之也是。

## 局部类

在一个函数体内定义的类为局部类，局部类只能在它的函数体内使用，超过该函数体则不可见

### 注意

1. 在局部类中不能说明静态成员
2. 局部类中所有成员函数都必须定义在函数体内