# 关键字 throw

throw 语句实际上是跳转，即命令程序跳到另一条语句。throw 关键字表示引发异常，紧随其后的值（例如字符串或对象）指出了异常的特征

# 异常处理程序（exception handler）

程序使用异常处理程序来捕获异常，异常处理程序位于要处理问题的程序中。

## catch块

catch 关键字表示捕获异常。处理程序以关键字 catch 开头，随后是位于括号中的类型声明，它指出了异常处理程序要响应的异常类型；然后是一个用花括号括起的代码块，指出要采取的措施。catch 关键字和异常类型用作标签，指出当异常被引发时，程序应跳到这个位置执行。异常处理程序也被称为 catch块

## try块

try块标识其中特定的异常可能被激活的代码块，它后面跟一个或多个 catch块。try块是由关键字 try指示的，关键字 try 的后面是一个由花括号括起的代码块，表明需要注意这些代码引发的异常。

<!-- 其使用与js中类似 -->

[Practice_47](../Practice/Practice_47.cpp)

[Practice_48](../Practice/Practice_48.cpp)

## 栈解退

假设 try 块没有直接调用引发异常的函数，而是调用了引发异常的函数进行调用的函数，则程序流程将从引发异常的函数跳到包含 try 块和处理程序的函数。其中将涉及到**栈解退（unwinding the stack）**

C++ 通常通过将信息放在栈中来处理函数调用。具体地说，程序将调用函数的指令的地址（返回地址）放到栈中。当被调用的函数执行完毕后，程序将使用该地址来确定从哪里开始继续执行。另外，函数调用将函数参数放到栈中。在栈中，这些函数参数被视为自动变量。如果被调用的函数创建了新的自动变量，则这些变量也将被添加到栈中。如果被调用的函数调用了另一个函数，则后者的信息将被添加到栈中，以此类推。当函数结束时，程序流程将跳到该函数被调用时存储的地址处，同时栈顶的元素被释放。因此，函数通常都返回到调用它的函数，以此类推，同时每个函数都在结束时释放其自动变量。如果自动变量是类对象，则类的析构函数将被调用。

现在假设函数由于出现异常（而不是由于返回）而终止，则程序也将释放栈中的内存，但不会在释放栈的第一个返回地址后停止，而是继续释放栈，直到找到一个位于 try块 中的返回地址。随后，控制将转到块尾的异常处理程序，而不是函数调用后的第一条语句。这个过程称为栈解退。

引发机制的一个非常重要的特性是，和函数返回一样，对于栈中的自动类对象，类的析构函数将被调用。然而，函数返回仅仅处理该函数放在栈中的对象，而 throw 语句则处理 try块 和 throw 之间整个函数调用序列放在栈中的对象。如果没有栈解退这种特性，则引发异常后，对于中间函数调用放在栈中的自动类对象，其析构函数将不会调用。

<!-- 见书 p507 图解 -->