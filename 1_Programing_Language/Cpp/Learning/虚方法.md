# 虚方法

## virtual关键字

如果使用了virtual，程序将根据引用或指向的对象的类型来选择方法

## 虚函数的工作原理

通常，编译器处理虚函数的方法是：给每个对象的添加一个隐藏成员。隐藏成员中保存了一个指向函数地址数组的指针。这种数组称为**虚函数表（virtual function table, vtbl）**。虚函数表中存储了为类对象进行声明的虚函数的地址。
<!-- 注意：无论类中包含的虚函数数目是多少，都只需要在对象中添加一个地址成员，只是表的大小不同而已 -->
调用虚函数时，程序将查看存储在对象中的vtbl地址，然后转向相应的函数地址表。如果使用类声明中定义的第一个虚函数，则程序将使用数组中的第一个虚函数地址，并执行具有该地址的函数。如此类推。


## 使用虚函数的成本

使用虚函数时，在内存和执行速度方面有一定的成本：
1. 每个对象都将增大，增大量为存储地址的空间
2. 对于每个类，编译器都创建一个虚函数地址表（数组）
3. 对于每个函数调用，都需要执行一向额外的操作，即到表中查找地址

## 使用虚函数的注意事项

1. 在基类方法的声明中使用关键字 virtual 可使该方法在基类以及所有的派生类（包括从派生类派生出来的类中使虚的）
2. 如果使用指向对象的引用或指针来调用虚方法，程序将使用为对象类型定义的方法，而不是用为引用或指针类型定义的方法。这成为动态联编，这将使得基类指针或引用可以指向派生类对象
3. 如果定义的类将被用作基类，则应将那些要在派生类中重新定义的类方法声明为虚的
4. 构造函数不能是虚函数；析构函数应当是虚函数，除非类不用做基类（virtual ~baseClass()）；友元不能是虚函数，因为友元不是类成员，而只有类成员才能使虚函数
5. 如果派生类没有重新定义函数，将使用该函数的基类版本。如果派生类位于派生链中，则将使用最新的虚函数版本，例外的情况是基类版本是隐藏的
6. 重新定义继承的方法并不是重载。如果重新定义派生类中的函数，将不只是使用相同的函数参数列表覆盖基类声明，无论参数列表是否相同，该操作将隐藏所有的同名基类方法，这说明：
   1. 如果重新定义继承的方法，因确保与原来的原型完全相同，但如果返回类型是基类引用或指针，则可以修改为指向派生类的引用或指针。这种特性被称为返回类型协变（covariance of return type），因为允许返回类型随类类型变化而变化（注意：这种变化只适用于返回值，而不适用于参数）
   2. 如果基类声明被重载，则应在派生类中重新定义所有版本的基类版本。如果只重新定义一个版本，则另外两个版本将被隐藏，派生类对象将无法使用它们。（注意：如果不需要修改，在新定义可只调用基类版本）

[Practice_43](../Practice/Practice_43.cpp)

## 纯虚函数

纯虚函数（pure virtual function）

C++可以通过使用纯虚函数提供未实现的函数

纯虚函数声明的结尾处为=0

```cpp
virtual type function() = 0; // a pure virtual function
```

当类声明中包含纯虚函数时，则不能创建该类的对象。这里的理念是，包含纯虚函数的类只能用作基类。