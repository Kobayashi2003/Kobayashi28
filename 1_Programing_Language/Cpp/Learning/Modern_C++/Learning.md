# 内联和嵌套命名空间

内联命名空间能够把空间内函数和类型导出到父命名空间中，这样即使不指定子命名空间也可以使用其空间中的类型和函数

```cpp
// C++ 11
namespace A {
    inline namespace B {
        ...
    }
}
```

**嵌套命名空间的简化语法**

```cpp
// C++ 17
namespace A::B::C {
    int foo() {return 17}
}

// C++ 20
namespace A::B::inline C {
    int foo() {return 20}
}
```


# auto 占位符

> C++11: 声明变量时根据初始化表达式自动推断该变量的类型、声明函数时函数返回值的占位符

**注意**

1. 当用一个 auto 关键字声明多个而变量的时候，编译器遵从由左往右的推导规则，以最左边的表达式推断 auto 的具体类型
2. 当使用条件表达式初始化 auto 声明的变量时，编译器总是使用表达能力更强的类型
3. C++ 17 声明静态成员 `static inline auto i = 5`
4. C++ 20 之前的标准，无法为函数形参列表中使用 auto 声明形参（在 C++ 14中，auto 可以为 lambda 表达式声明形参）

**推导规则**

1. 如果 auto 声明的变量是按值初始化，则推导出的类型会忽略 cv 限定符。进一步解释为，在使用 auto 声明变量时，既没有使用引用，也没有使用指针，那么编译器在推导的时候会忽略 const 和 volatile 限定符。当然 auto 本身也支持添加 cv 限定符
2. 使用 auto 声明变量初始化时，目标对象如果是引用，则引用属性会被忽略
3. 使用 auto 和万能引用声明变量时，对于左值会将 auto 推导为引用类型
4. 使用 auto 声明变量，如果对象是一个数组或函数，则 auto 会被推导为对应的指针类型
5. C++17
   1. 直接使用列表初始化，列表中必须为单元素，否则无法编译，auto 类型被推到为单元素的类型
   2. 用等号加列表初始化，列表中可以包含单个或者多个元素，auto 类型被推导为 std::initializer_list<T>，其中 T 为元素类型。请注意，在列表中包含多个元素时，元素的类型必须相同，否则编译器会报错

**返回类型推导**

> C++14 标准支持对返回类型声明为 auto 的推导

**lambda 表达式中使用 auto 类型推导**

在 C++14 标准中我们还可以把 auto 写到 lambda 表达式的形参中，由此得到一个泛型的 lambda 表达式

```CPP
auto l = [](auto a1, auto a2) {return a1 + a2;};
auto retval = l(14, 20.0);
```

**非类型模板形参占位符**

> C++17 标准对 auto 关键字又一次进行扩展，使它可以作为非类型模板形参的占位符


# 指针字面量 nullptr（C++11）

**零值整形字面量**

**nullptr 关键字**

> 在 C++11 中添加的关键字，它是一个 std::nullptr_t 类型的纯右值

- 它不允许运用在算术表达式中或者与非指针类型进行比较（除了空指针常量 0）
- 它还可以隐式转换为各种指针类型，但无法隐式转换到非指针类型


# typename 优化（C++17 C++20）

> 在 C++17 之前，必须使用 class 来声明模板形参是对，而 typename是不允许使用的

> C++20 标准中，增加了一些情况可以让我们省略 typename 关键字

<!-- TODO -->


# 基于范围的 for 循环

> C++11 标准引入了基于范围的 for 循环特性，该特性隐藏了迭代器的初始化和更新过程

`for ( range_declaration : range_expression ) loop_statement`

基于范围的 for 循环语句不需要初始化语句、条件表达式以及更新表达式，取而代之的是一个范围声明和一个范围表达式。其中范围声明是一个变量的声明，其类型是范围表达式中元素或者元素类型的引用。而范围表达式可以是数组或对象，对象必须满足以下 2个条件中的任意一个：

1. 对象类型定义了 begin 和 end 成员函数
2. 定义了以对象类型为参数的 begin 和 end 普通函数

```CPP
#include <iostream>
#include <string>
#include <map>

std::map<int, std::string> index_map{ {1, "hello"}, {2, "world"}, {3, "!"} };
int int_array[] = { 0, 1, 2, 3, 4, 5};


int main() {

    for (const auto &e : index_map) {
        std::cout << "key=" << e.first << " value=" << e.second << std::endl;
    }

    for (auto e : int_array) {
        std::cout << e << std::endl;
    }

    return 0;
}

// 值得注意的是，代码使用了两种形式的范围声明，前者是容器或者数组中元素的引用。
// 一般来说，我们希望对于复杂的对象使用引用，而对于基础类型使用值，因为这样能够减少内存的复制。
// 如果不会在循环过程中修改引用对象，那么推荐在范围声明中加上 const 限定符以帮助编译器生成更加高效的代码
```


# lambda 表达式（C++11 ~ C++20）

**语法**

`[ captures ] (params) specifiers exception -> ret { body }`

- [ captures ]  ———— 捕获列表，它可以捕获当前函数作用域的零个或多个变量。捕获变量后，我们可以在 lambda 表达式函数体内使用这个变量。另外，捕获列表的捕获方式有两种：按值捕获 和 引用捕获
- ( params ) ———— 可选参数列表，语法和普通函数的参数列表一样，在不需要参数的时候可以忽略参数列表
- specifiers ———— 可选限定符，C++11 中可以用 mutable，它允许我们在 lambda 表达式函数体类内改变按值捕获的变量，或者调用非 const 的成员函数
- exception ———— 可选异常说明符，我们可以使用 noexcept 来指明 lambda 是否会抛出异常
-  ret ———— 可选返回值类型，不同于普通函数，lambda 表达式使用返回类型后置的语法来表示返回类型，如果没有返回值（void类型），可以忽略包括 -> 在内的整个部分。另外，我们也可以在有返回值的情况下不指定返回类型，这是编译器会为我们推导出一个返回类型
-  { body } ———— lambda 表达式的函数体，这个部分和普通函数的函数体一样

**捕获列表**

- 作用域

捕获列表中的变量存在于两个作用域————lambda 表达式定义的函数作用域以及 lambda 表达式函数体的作用域。前者是为了捕获变量，后者是为了使用变量。另外，标准还规定能捕获的变量必须是一个自动存储类型。简单来说就是非静态的局部变量。（全局变量存储与静态存储区）


- 捕获值和捕获引用

捕获值是将函数作用域的 x 和 y 复制到 lambda 表达式对象的内部，就如同 lambda 表达式的成员变量一样。捕获引用的语法和捕获值只有一个 & 的区别，类似于取变量指针。只不过这里捕获的是引用而不是指针，在 lambda 表达式内可以直接使用变量名访问变量而不需解引用

lambda 捕获的变量默认为常量，或者说 lambda 是一个常量函数。因为捕获的变量默认为常量指的是变量本身，当变量按值捕获的时候，变量本身就是值，所以改变值就会发生错误。相反，在捕获引用的情况下，捕获变量实际上是一个引用，我们在函数体内改变的并不是引用本身，而是引用的值。

使用 mutable 说明符可以溢移除 lambda 表达式的常量性，也就是说我们可以在 lambda 表达式的函数体中修改捕获值的变量了


**特殊的捕获方法**

- `[this]` ———— 捕获 this 指针，捕获 this 指针可以让我们使用 this 类型的成员变量和函数
- `[=]` ———— 捕获 lambda 表达式定义作用域的全部变量的值，包括 this
- `[&]` ———— 捕获 lambdas 表达式定义作用域的全部变量的引用，包括 this


**lambda 表达式的实现原理**

lambda 表示是通过函数对象进行实现的

lambda 表达式在编译器会由编译器自动生成一个闭包类，在运行时由这个闭包类产生一个对象，我们称它为闭包。在 C++ 中，所谓的闭包可以理解为匿名且可以包含定义是作用域上下文的函数对象

从某种程度上来说， lambda 表达式时 C++11 给我们提供的语法糖，lambda 表达式的功能完全能够通过手动实现

**无状态 lambda 表达式**

C++ 标准对于无状态的 lambda 表达式有着特殊的照顾，即它可以隐式转换为函数指针

```cpp
// 例如下面的代码能够顺利通过编译
void f(void(*) ()){}
void g() { f([]{}); }
```

**在 STL 中使用 lambda 表达式**

C++11 之后我们可以通过使用 lambda 表达式在 STL 算法函数的参数列表内实现辅助函数

例如：
```CPP
#include <iostream>
#include <vector>
#include <algorithm>

int main() {

    std::vector<int> x = {1, 2, 3, 4, 5};
    std::cout << *std::find_if(x.cbegin(), x.cend(), [](int i) { return (i % 3) == 0; }) << std:endl;

    return 0;
}

```

**广义捕获**

C++14 标准中定义了广义捕获，所谓广义捕获实际上式两种捕获方式，第一种称为简单捕获，这种捕获就是我们在前文中提到的捕获方法。第二种叫做初始化捕获，这种捕获方式是在 C++14 标准中引入的，它解决了简单捕获的一个重要问题，即只能捕获 lambda 表达式定义上下文的变量，而无法捕获表达式结果以及自定义捕获变量名

1. 使用移动操作减少代码运行的开销
```CPP
#include <string>

int main() {

    std::string x = "hello c++";
    auto foo = [x = std::move(x)] {return x + "world!"};
    return 0;
}
// 上面这段代码使用 std::move 对捕获列表 x 进行初始化，这样避免了单捕获的复制对象操作，代码的运行效率得到了提升
```

2. 在异步调用时复制 this 对象，防止 lambda 表达式被调用时因原始 this 对象被析构造成未定义行为
```CPP
#include <iostream>
#include <future>

class Work {
private:
    int value;
public:
    Word() : value(42);
    
}
```


# 并行与并发

**并行基础**

**互斥量与临界区**

**期物**

**条件模型**

**条件变量**

**原子操作与内存模型**

