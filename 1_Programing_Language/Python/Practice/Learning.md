# Python

[toc]

[如何将python文件打包为exe文件](https://blog.csdn.net/m0_63203517/article/details/124383678)

# 交互式运行 Python 程序

- 直接在终端中运行解释器，而不输入要执行的文件名
- 在 Python 的 shell 中直接输入 Python 的代码，会立即看到程序执行结果

# IPython

<!-- cmd 下载完之后记得为它配置环境变量（放在 Python的 Script 文件夹下） -->

- IPython 是一个 python 的 **交互式shell**

  - 支持自动补全
  - 自动缩进
  - 支持 bash shell 命令
  - 内置了许多功能和函数
- IPython 是基于 BSD 开源的

# Python 的 IDE -- Pycharm

1. 集成开发环境（IDE）
   <!-- IDE Integrated Development Environment -->
   - 图形用户界面
   - 代码编辑器
   - 编译器/解释器
   - 调试器
   - ...

2. Pycharm 介绍

- PyCharm 能在 Windows、Linux、macOS下使用
- PyCharm 适合开发大型项目

# PyCharm 的安装、设置及使用

# 注释

单行注释：
`# 内容`

多行注释：
`"""内容"""`

TODO注释：
`TODO(作者/邮件)`

# 运算符

## 算数运算符

运算符|描述
-|-
+|加
-|减
*|乘
/|除
//|取整除
%|取余数
**|幂

## 比较运算符

运算符|描述
==|相等
!=|不相等
\>|大于
<|小于
\>=|大于或等于
<=|小于或等于

## 逻辑运算符

- Python 中的 逻辑运算符 包括：and（与）/ or（或）/ not（非） 三种

<!-- Python2.x 中判断不等于还可以使用 `<>` 运算符 -->

## 赋值运算符

运算符|描述
-|-
=|简单的赋值运算符
+=|加法赋值运算符
-=|减法赋值运算符
*=|乘法赋值运算符
/=|除法赋值运算符
//=|取整除赋值运算符
%=|取摸赋值运算符
**=|幂赋值运算符

## 字符串中的转义字符

- `\t` 在控制台输出一个 制表符，协助在输出文本时 垂直方向 保持对齐
- `\n` 在控制台输出一个 换行符
- `\\` 反斜杠符号
- `\'` 单引号
- `\n` 换行
- `\t` 横向制表符
- `\r` 回车

## 身份运算符

身份运算符用于 比较 两个对象的 内存地址 是否 一致 -- 是否是对同一个对象的引用

- 在 Python 中针对 `None` 比较时，建议使用 `is` 判断

运算符|描述
is|is 是判断两个标识符是不是引用同一个对象
is not|is not 判断两个标识符是不是引用不同对象

# 关键字、函数和方法

- 关键字 是 Python 内置的、具有特殊7意义的标识符
- 函数 封装了独立功能，可以直接调用
- 方法 需要通过 对象 来调用，表示针对这个 对象 要做的操作

# 随机数的处理

`import random`

`random.randint(a, b)` 返回 [a, b] 之间的整数，包含 a 与 b

在 ipython 中导入一个模块之后，可以直接在模块名称后面敲一个 . 然后按 Tab 键，会提示该模块中的所有函数

<!-- PS C:\users\17312\appdata\local\packages\pythonsoftwarefoundation.python.3.10_qbz5n2kfra8p0\localcache\local-packages\python310\site-packages> python ipython -->

# 对 print 函数的补充

- 在默认情况下，`print` 函数输出内容后，会自动在内容末尾增加换行 <!--单纯的换行 `print("")`-->
- 如果不希望末尾增加华航，可以在 print 函数输出内容的后买你增加，`end=""`
- 其中 `""` 中间可以指定 `print` 函数输出内容之后，继续希望显示的内容

# 程序执行原理

## 计算机中的三大件

计算机中包含有较多的硬件，但是一个程序要运行，有 三个 核心的硬件，分别是：

1. CPU
   - 中央处理器，是一块超大规模的集成电器
   - 负责 处理数据/计算机

2. 内存
   - 临时 存储数据（断电之后，数据会丢失）
   - 速度快
   - 空间小
   - 价格高

3. 硬盘
   - 永久 存储数据
   - 速度慢
   - 空间大
   - 价格便宜

## 程序执行原理

CPU <---> 内存 <---> 硬盘

1. 程序 运行之前，程序是 保存在硬盘 中的
2. 当要运行一个程序时
  - 操作系统会先让 CPU 把程序复制到 内存 中
  - CPU 执行 内存 中的 程序代码

> 程序要执行，首先要被加载到内存中

## Python 程序执行原理

CPU <---> 内存（Python 解释器） <---> 硬盘

1. 操作系统会首先让 CPU 把 Python 解释器 的程序复制到 内存 中
2. Python 解释器 根据语法规则，从上向下 让 CPU 翻译 Python 程序中的代码
3. CPU 负责执行翻译完成的代码


# 变量的基本使用

## 变量定义

## 变量的类型

- 在内存中创建一个变量，会包括：
  1. 变量的名称
  2. 变量保存的数据
  3. 变量存储数据的类型
  4.变量的地址（标示）

- 在 Python 中，定义变量时不需要指定变量类型
- 运行时，Python 解释器会根据复制语句等号右侧的数据自动推导出变量中保存数据的准确类型

- 数字型
  - bool -- 布尔
  - int -- 整数 <!-- 在 Python2.x 中，整数根据保存数值的长度还分为 int 与 long -->
  - float -- 浮点数
  - complex -- 复数型
- 非数字类型
  - str -- 字符串
  - 列表
  - 元组
  - 字典

- 使用 `type()` 函数可以查看一个变量的类型

## 不同类型变量直接的计算

1. 数字型变量之间可以直接计算
2. 字符串变量直接使用 + 拼接字符串
3. 字符串变量 可以和 整数 使用 * 重复拼接相同的字符串
4. 数字型变量 和 字符串之间不能进行其他计算

## 变量的输入

- 在 Python 中，如果要获取用户在 键盘 上的输入信息，需要用到 `input()` 函数

`字符串变量 = input("输入提醒:")`

## 类型转换函数

函数|说明
-|-
int(x)|将 x 转换为一个整数
float(x)|将 x 转换为一个浮点数

## 变量的格式化输出

- 在 Python 中可以使用 `print()` 函数将信息输出到控制台
- 如果希望输出文字信息的同时，一起输出数据，就需要使用到格式化操作符
- `%` 被称为 格式化操作符，专门用于处理字符串中的格式
  - 包含 `%` 的字符串被称为 格式化字符串
  - `%` 和不同的 字符 连用，不同类型的数据 需要使用 不同的格式化字符

格式化字符|含义
-|-
%s|字符串
%d|有符号十进制整数，%06d 表示输出的整数显示位数，不足的地方使用 0 补全
%f|浮点数，%.02f 表示小数点后只显示两位
%%|输出 %

`print("格式化字符串" % (变量1， 变量2， ...))`

## 变量的命名

### 关键字

通过以下命令可以查看 Python 中的关键字
```py
import keyword
print(keyword.kwlist)
```

### 变量的命名规则


# 判断（if）语句

## if 判断语句基本语法

- if 语句以及缩进部分是一个 完整的代码块

```py
if 条件:
   条件满足时执行的语句
```

## else 处理条件不满足的情况

if 和 else 语句以及各自的缩进部分共同是一个完整的代码块

```py
if 条件:
   ...
else :
   ...
```

## elif

```py
if condition1:
   ...
elif condition2:
   ...
else :
   ...
```

## if 的嵌套

```py
if condition1:
   ...
   if condition2:
      ...
```

## pass

如果在开发程序时，不希望立刻编写分支内部的代码，可以使用 pass 关键字，表示一个占位符，能够保证程序代码结构的正确，程序执行时，pass 不会进行任何操作

# 循环

## while 循环

```py
while condition:
   ...
```

## break 和 continue

## 循环嵌套


# 函数

- 定义函数 -- 封装 独立的功能
- 调用函数 -- 享受 封装 的成果

## 函数的定义

```py
def functionName():
   ...
```

- def 是 define 的缩写

## 函数中增加文档注释注释

使用 `"""注释内容"""`

## 函数的参数

```py
def functionName(parameter1, parameter2, ...):
   ...
```

## 形参和实参

## 函数的返回值

`return`

## 函数的嵌套调用

一个函数里面 又调用了 另外一个函数，叫做函数的嵌套调用

# 使用模块中的函数

> 模块是 Python 程序架构的一个核心概念

- 模块 就好比是 工具包，要想使用这个工具包中的工具，就需要 导入 import 这个模块
- 每一个扩展名 .py 结尾的 Python 源代码文件都是一个 模块
- 在模块中定义的 全局变量，函数 都是模块能够提供给外界直接使用的工具


- 模块名也是一个标识符

## Pyc 文件

> C 是 compiled 编译过的意思

### 操作步骤

1. 浏览程序目录会发现一个 __pycache__ 的目录
2. 目录下会有一个 .pyc 文件，文件名中的 cpython-xx 表示 Python 解释器的版本
3. 这个 pyc 文件是由 Python 解释器将 模块的源码 转换为 字节码
   - Python 这样保存字节码是作为一种启动速度的优化

### 字节码

- Python 在解释源程序时是分为两个步骤的：
  - 首先处理源代码，编译 生成一个二进制 字节码
  - 在对 字节码 进行处理，才会生成 CPU 能够识别的 机器码
- 有了模块的字节码文件之后，下一次运行程序时 ，如果在 上次保存字节码之后 没有修改过源代码，Python 将会加载 .pyc 文件并跳过编译这个步骤
- 当 Python 重编译时，它会自动检查源文件和字节码文件的时间戳
- 如果你修改了源代码，下次程序运行时，字节码将会自动重新创建


# 高级变量类型

- 列表
- 元组
- 字典
- 字符串
- 公共方法
- 变量高级

- 在 Python 中，所有 非数字型变量 都支持以下特点：
  1. 都是一个序列 sequence，也可以理解为 容器
  2. 取值 `[]`
  3. 遍历 `for in`
  4. 计算长度、最大/最小值、比较、删除
  5. 链接 `+` 和 重复 `*`
  6. 切片

## 列表

### 列表的定义

- List 是 Python 中使用最频繁的数据类型，在其它语言中通常叫做 数组
- 专门用于存储一串信息
- 列表用 `[]` 定义，数据之间使用 `,` 分隔
- 列表的索引从 `0` 开始

### 列表常用操作
- 在 ipython3 中定义一个 列表，输入 列表名. 按下 TAB 键会提示 列表 能够使用的 方法

1. 取值和取索引

取值 `[]`

取索引 `.index()` 列表.index(数据)

2. 修改

3. 增加

向列表末尾追加数据 `.append()` 列表.append(数据)

向列表的指定索引位置插入数据 `.insert()` 列表.insert(索引, 数据)

把其它列表中的完整内容追加到当前列表的末尾 `extend()` 列表1.extend(列表2)

4. 删除

`del` 关键字 del 列表[索引]
> del 关键字本质上是用来将一个变量从内存中删除的

`.remove()` 删除第一个出现的指定数据 列表.remove(数据)

`.clear()` 清空整个列表 列表.clear()

`.pop()` 把索引所指向的数据删除并返回，默认可以把列表最后一个数据删除 列表.pop() 列表.pop(索引)

5. 统计

`len()` 统计列表中元素的总数 len(列表)

`.count()` 统计列表中某一个数据出现的次数 列表.count(数据)

6. 排序

`.sort()` 升序排序 列表.sort()

`.sort(reverse=True)` 降序排序

`.reverse()` 翻转列表中的元素

### 列表的循环遍历

```py
for i in l:
   ...
```


# 元组

## 元组的定义

- Tuple 与列表类似，但是元组中的 元素不能修改
- 元组用 `()` 定义

## 定义单个元素的元组

```python
info_tuple = （5,）
# 元组中只包含一个元素时，需要在元素后面加逗号
```

## 元组变量的常规操作

### 取值取索引

`.index`

### 统计计数

`.count`

### 统计元组中元素的个数

`len()`

### 循环遍历

### 实际应用

格式化字符串后面的 `()` 本质上就是元组

### 元组和列表之间的转换

- 使用 list 函数可以把元组转换为列表 `list(元组)`
- 使用 tuple 函数可以把列表转换成元组 `tuple(列表)`


# 字典

- dictionary

- 和列表的区别
   - 列表 是 有序 的对象集合
   - 字典 是 无序 的对象集合
- 字典用 `{}` 定义
- 字典使用 键值对 存储数据，键值对之间使用 `,` 分隔
   - 键 `key` 是索引
   - 值 `value` 是数据
   - 键 和 值 之间使用 `:` 分隔
   - 值必须是唯一的
   - 值 可以取任何数据类型，但 键 只能使用 字符串、数字或元组

## 取值

`dict[key]`
<!-- 在取值的时候，如果key不存在，程序将会报错 -->

## 增加/修改

在赋值的时候，如果key不存在，会新增键值对；如果key存在，会修改已经存在的键值对

## 删除

`.pop()`

## 统计键值对数量

`len()`

## 合并字典

`.update()` 如果被合并的字典中包含已经存在的键值对，会覆盖原有的键值对

## 清空字典

`.clear()`

## 循环遍历

```py
for k in dictionary:
   ...
```


# 字符串

- 字符串 就是 一串字符，是编程语言中表示文本的数据类型
- 在 Python 中可以使用 `""` 或 `''` 来定义一个字符串
- 也可以使用 索引 获取一个字符串中指定位置的字符，索引计数从 0 开始

## 统计字符串长度

`len()`

## 统计某一个小字符串出现的次数

`.count()`

## 判断某一个子字符串出现的位置

`.index()`

### 判断类型

### 查找和替换

### 文本对齐

### 去除空白字符

### 拆分和连接

### 字符串的切片

字符串[开始索引:结束索引:步长]

逆序 str[-1::-1] 或 str[::-1]


# 公共方法

## Python 内置函数

函数|描述|备注
-|-|-
len(item)|计算容器中元素个数|
del(item)|删除变量|del 有两种方式
max(item)|返回容器中元素最大值|如果是字典，只针对 key 比较
min(item)|返回容器中元素最小值|如果是字典，只针对 key 比较
cmp(item1, item2)|比较两个值，-1 小于 /0 相等 /1 大于|Python 3.x 中取消了 cmp 函数


## 切片

- 切片 使用 索引值 来限定范围，从一个大的 字符串 中 切出 小的 字符串
- 列表 和 元组 都是 有序 的集合，都能够 通过索引值 获取到对应的数据
- 字典 是一个 无序 的集合，是使用 键值对 保存数据

## 运算符

运算符|描述|支持的数据类型
-|-|-
+|合并|字符串、列表、元组
*|重复|字符串、列表、元组
in|元素是否存在|字符串、列表、元组、字典
not in|元素是否不存在|字符串、列表、元组、字典
\> \>= == < <=|元素比较|字符串、列表、元组

注意：
- `in` 在对 字典 操作时，判断的时 字典的键
- `in` 和 `not in` 被称为 成员运算符

## 完整的 for 循环语法

- 在 Python 中完整的 for 循环 语法如下：

```py
for 变量 in 集合:
   循环体代码
else:
   没有通过 break 退出循环，循环结束后，会执行的代码
```

### 应用场景

- 在 迭代遍历 嵌套的数据类型时，例如 一个列表包含多个字典
- 需求：要判断 某一个字典中 是否存在 指定的 值
  - 如果 存在，提示并且退出循环
  - 如果 不存在，在 循环整体结束 后，希望得到一个统一的提示


# LINUX 上的 Shebang 符号 `#!`

- `#!` 这个符号叫做 `Shebang` 或者 `Sha-bang`
- `Shebang` 通常再 `Unix` 系统脚本中 第一行开头 使用
- 指明 执行这个脚本文件 的解释程序

## 使用 Shebang 的步骤

1. 使用 `which` 查询 `python3` 解释器所在的路径

2. 修改要运行的 主 python 文件，在第一行增加以下内容
`#! /usr/bin/python3`

3. 修改 主 python 文件 的文件权限，增加执行权限
`chmod +x cards_main.py`

4. 在需要时执行程序即可

`./cards_main.py`


# 变量进阶

## 变量的引用

- 变量 和 数据 都是保存在 内存 中的
- 在 Python 中函数的 参数传递 以及 返回值 都是靠 引用 传递的

### 引用的概念

在 Python 中

- 变量 和 数据 是分开存储的
- 数据 保存在内存中的一个位置
- 变量 中保存着数据在内存中的地址
- 变量 中 记录数据的地址，就叫做引用（数据的地址本质上就是一个数字）
- 使用 `id()` 函数可以查看变量中保存数据所在的 内存地址

> 注意：如果变量已经被定义，当给一个变量赋值的时候，本质上是 修改了数据的引用
>  - 变量 不再 对之前的数据引用
>  - 变量 改为 对新赋值的数据引用


### 函数的引用和返回值的传递

调用函数时，本质上传递的是实参保存数据的引用，而不是实参保存的数据

函数返回时，返回的是数据的引用，而不是数据本身

## 可变和不可变类型

- 不可变类型，内存中的数据不允许被修改：
  - 数字类型
  - 字符串
  - 元组
- 可变类型，内存中的数据可以被修改
  - 列表 list
  - 字典 dict（注意：字典的 key 只能使用不可变类型的数据）

注意：
1. 可变类型的数据变化，是通过 方法 来实现的
2. 如果给一个可变类型的变量，赋值了一个新的数据，引用会修改
   - 变量 不再 对之前的数据引用
   - 变量 改为 对新赋值的数据引用

## 哈希（hash）

- Python 中内置有一个名字叫做 `hash(o)` 的函数
  - 接收一个 不可变类型 的数据作为参数
  - 返回 结果是一个 整数
- 哈希 是一种 算法，其作用就是提取数据的 特征码
  - 相同的内容 得到 相同的结果
  - 不同的内容 得到 不同的结果
- 在 Python 中，设置字典的 键值对 时，会首先对 key 进行 hash 已决定如何在内存中保存字典的数据，以方便后续对字典的操作
  - 键值对的 key 必须是不可变类型数据
  - 键值对的 value 可以是任意类型的数据


## 局部变量与全局变量

- 局部变量 是在 函数内部 定义的变量，只能在函数内部使用
- 全局变量 是在 函数外部定义 的变量（没有定义在某一函数内），所有函数 内部都可以使用这个变量

### 局部变量

- 局部变量 是在 函数内部 定义的变量，只能在函数内部使用
- 函数执行结束后，函数内部的局部变量，会被系统回收
- 不同的函数，可以定义相同的名字的局部变量，但是各用各的不会产生影响

**局部变量的作用**

- 在函数内部使用，临时 保存 函数内部需要使用的数据

**局部变量的生命周期**

- 所谓 生命周期 就是变量从 被创建 到 被系统回收 的过程
- 局部变量 在 函数执行时 才会被创建
- 函数执行结束后 局部变量 被系统回收
- 局部变量在生命周期内，可以用来存储 函数内部临时使用到的数据

### 全局变量

注意：函数执行时，需要处理变量时 会：

1. 首先查找 函数内部 是否存在 指定名称 的 局部变量，如果有，直接使用
2. 如果没有，查找 函数外部 是否存在 指定名称的全局变量，如果有，直接使用
3. 如果还没有，系统报错

**函数不能直接修改全局变量的引用**

- 全局变量 是在 函数外部定义 的 变量（没有定义在某一个函数内），所有函数 内部都可以使用这个变量
- 在函数内部，可以 通过全局变量的引用来获取对应的数据
- 但是，不允许直接修改全局变量的引用--使用赋值语句修改全局变量的值


**在函数内部修改全局变量的值**

- 如果在函数中需要修改全局变量，需要使用 `global` 进行声明
<!-- 在开发时，应该把模块中所有全局变量定义在所有函数上方，就可以保证所有的函数都能够正常地访问到全部全局变量 -->
- global 关键字会告诉解释器后面的变量是一个全局变量，再使用赋值语句时，就不会创建局部变量

```python
data = 1


def demo():
   global data
   data = 2
```

# 函数的返回值进阶

- 元组可以包含多个数据，因此可以使用元组使函数一次性返回多个数值
- 如果函数返回的类型是元组，小括号可以省略

- 如果函数返回的类型是元组，同时希望单独的处理元组中的元素，可以使用多个变量，一次接收函数的返回结果（注意：使用多个变量接受结果时，变量的个数应该和元组中的元素的个数保持一致）

## 不可变和可变的参数

- 在函数内部，针对参数使用 赋值语句，不会影响调用函数时传递的 实参变量
- 无论传递的参数是可变还是不可变，只要 针对参数 使用赋值语句，会在 函数内部 修改 局部变量的引用，不会影响到外部变量的引用
- 如果传递的参数是 可变类型，在函数内部，使用 方法 修改了数据的内容，同样会影响到外部的数据

- 在 Python 中，对列表使用 += 本质上是在调用列表的 extend 方法


## 缺省参数

- 定义函数时，可以给 某个参数指定一个默认值，具有默认值的参数就叫做 缺省参数
- 调用函数时，如果没有传入 缺省参数 的值，则在函数内部使用定义函数时指定的 参数默认值
- 函数的缺省参数，将常见的值设置为参数的缺省值，从而 简化函数的调用

### 指定函数的缺省参数

- 在参数后使用赋值语句，可以指定参数的缺省值

### 缺省参数的定义位置

- 必须保证 带有默认值的缺省参数 在参数列表末尾

### 调用带有多个缺省参数的函数

- 在 调用函数时，如果有 多个缺省参数，需要指定参数名，这样解释器才能知道参数的对应关系

### 多值参数

定义支持多值参数的函数

- 有时可能需要 一个函数 能够处理的参数 个数 是不确定的，这个时候，就可以使用 多值参数
- python 中有 两种 多值参数
  - 参数名前增加 一个 `*` 可以接收 元组
  - 参数名前增加 两个 `*` 可以接收 字典
- 一般在给多指参数命名时，习惯使用以下两个名字
  - *args -- 存放 元组参数
  - **kwargs -- 存放字典参数


## 元组和字典的拆包

- 在调用带有多值参数的函数时，如果希望：
  - 将一个 元组变量，直接传递给 args
  - 将一个 字典变量，直接传递给 kwargs
- 就可以使用 拆包，简化参数的传递，拆包 的方式是：
  - 在 元组变量前，增加 `*`
  - 在 字典变量前，增加 `**`


## 函数的递归


# 类和对象

## dir 内置函数

- 在 Python 中 对象几乎是无处不在的，我们之前学习的 变量、数据、函数 都是对象
- 在 Python 中可以使用一下两个方法验证：
  - 在 表示符 / 数据 后输入一个 `.` 然后按下 TAB 键，ipython 会提示该对象能够调用的 方法列表
  - 使用内置函数 `dir` 传入 表示符/数据，可以查看对象内的 所有属性及方法


方法名|类型|作用
-|-|-
__new__|方法|创建对象时，会被自动调用
__init__|方法|对象被初始化时，会被自动调用
__del__|方法|对象被从内存中销毁前，会被自动调用
__str__|方法|返回对象的描述信息，print 函数输出使用

## 类的定义以及对象的创建

```python
class className:
   def demo(self, parameters, ...):
      pass


className c
```

**引用概念的强调**

> 在面向对象开发中，引用的概念是同样适用的

- 使用 print 输出 变量对象，默认情况下，是能够输出这个变量 引用的对象 是 由哪一个类创建的兑现，以及 在内存中的地址（十六进制表示）

`%d` 可以输出十进制数字
`%x` 可以输出十六进制数字


## 方法中的 self 参数

- 在 Python 中，要给对象设置属性，只需要在 类的外部的代码中直接通过 `.` 设置一个属性即可

<!-- 但是并不推荐这种方法，因为对象属性的封装应该封装在类的内部，且如果在运行时，没有找到属性，程序会报错 -->

- 哪一个对象调用的方法，方法内的 `self` 就是哪一个对象的引用
- 调用方法时，不需要传递 `self` 参数
- 在方法内部
  - 可以通过 `self.` 访问对象的属性
  - 也可以通过 `self.` 调用其它对象方法


## 初始化方法

- 当使用 `className()` 创建对象时，会自动执行以下操作：
   1. 为对象在内存中 分配空间 -- 创建对象
   2. 为对象的属性 设置初始值 -- 初始化方法 (__init__)
   3. `__init__` 方法是对象的内置方法，专门用于定义一个类 的属性与方法，该函数将会在对象被创建时自动被调用

## 在初始化方法内部定义属性

- 在 `__inti__` 方法内部使用 `self.属性名 = 属性的初始值` 就可以 定义属性


## 改造初始化方法 -- 初始化的同时设置初始值

- 把希望设置的属性值，定义成 `__init__` 方法的参数
- 把方法内部使用 `self.属性 = 形参` 接收外部传递的参数

## 内置方法和属性

方法名|类型|作用
-|-|-
__del__|方法|对象被从内存中销毁前，会被自动调用
__str__|方法|返回对象的描述信息，print函数输出使用

- **生命周期**
  - 一个对象从调用 `类名()` 创建，生命周期开始
  - 一个对象的 `__del__` 方法一旦被调用，生命周期结束
  - 在对象的生命周期内，可以访问对象属性，或者调用对象方法

- 在 Python 中，使用 `print` 输出 对象变量，默认情况下，会输出这个变量 引用的对象 是 由哪一个类创建的兑现，以及 在内存中的地址（十六进制表示）
- 如果在开发中，希望使用 `print` 输出 对象变量时，能够打印自定以的内容，就可以利用 __str__
<!-- 注意: __str__ 方法必须返回一个字符串 -->

- 在 对象的方法内部，是可以 直接访问对象的属性 的
- 同一个类 创建的 多个对象 之间，属性互不干扰

- 一个对象的 属性 可以是 另外一个类创建的对象

## 私有属性和私有方法

### 定义方式

- 在 定义属性或方法时，在 属性名或者方法名前 增加 两个下划线 `__`，定义的就是 私有 属性或方法

### 伪私有属性和私有方法

> 在 Python 中没有真正意义的 私有

- 在给 属性、方法 命名时，实际是对 名称 做了一些特殊处理，使得外界无法访问到
- 处理方式：在名称前面加上 _类名 => _类名__名称


# 继承

**面向对象三大特性**

1. 封装 根据 职责 将 属性 和 方法 封装 到一个抽象的 类 中
2. 继承 实现代码的重用，相同的代码不需要重复的编写
3. 多态 不同的对象调用相同的方法，产生不同的执行结果，增加代码的灵活度

**继承的概念**

子类 拥有 父类 的 所有 方法 和 属性

**继承的语法**

```python
class 类名(父类名):
   pass
```

- 子类 继承自 父类，可以直接使用父类中已经封装好的方法，不需要再次开发
- 子类 中应该根据 职责，封装 子类特有的属性和方法

**继承的传递性**

子类 拥有 父类 以及父类的父类 中封装的所有 属性 和 方法

## 方法的重写

- 当 父类 的方法实现不能满足子类需求时，可以对方法进行 重写（override）

**重写的两种情况**
1. 覆盖 父类方法

   - 如果在开发中，父类的方法实现 和 子类的方法实现完全不同，就可以使用 覆盖 的方式，在子类中 重新编写 父类的方法实现
   - 具体的实现方式，就相当于在 子类中 定义了一个 和父类同名的方法并且实现
   - 重写之后，在运行时，只会调用 子类中 重写的方法，而不会再调用 父类封装的方法

2. 对父类方法进行 扩展

   - 如果在开发中，子类的方法实现 中 包含父类的方法实现，就可以使用扩展的方式
      1. 在子类中 重写 父类的方法
      2. 在需要的位置使用 `super().父类方法` 来调用父类方法的执行
      3. 代码其它的位置针对子类的需求，编写子类特有的代码实现

**关于 super**

- 在 Python 中 `super` 是一个特殊的类
- `super()` 就是使用 `super` 类创建出来的对象
- 最常使用的场景就是在 重写父类方法时，调用 在父类中封装的方法实现


## 父类的 私有属性 和 私有方法

1. 子类对象 不能 在自己的方法内部，直接访问父类的 私有属性 或 私有方法
2. 子类对象可以通过 父类的公有方法 间接 访问到 私有属性 或 私有方法


## 多继承

- 子类 可以拥有 多个父类，并且具有 所有父类 的 属性 和 方法

```python
class 子类名(父类名1, 父类名2, ...):
   pass
```

**Python 中的 MRO -- 方法搜索顺序**

- Python 中针对 类 提供了一个 内置属性 `__mro__` 可以查看 方法搜索顺序
- MRO 时 method resolution order，主要用于 在多继承时判断 方法、属性 的调用 路径
- 在搜索方法时，是按照 `__mro__` 的输出结果 从左至右 的顺序查找的如果在当前类中 找到方法，就直接执行，不再搜索
- 如果 没有找到，就查找下一个类 中是否有对应的方法, 如果找到方法，就直接执行，不再搜索
- 若最后都没有找到，程序报错

**新式类与旧式类**

> `object` 是 Python 为 对象提供 的基类，提供有一些内置的属性和方法，可以使用 `dir` 函数查看

- 新式类：以 `object` 为基类的类，推荐使用
- 旧式类：不以 `object` 为基类的类，不推荐使用
- 在 Python 3.x 中定义类时，如果没有指定父类，会 默认使用 `object` 作为基类
- 在 Python 2.x 中定义类时，如果没有指定父类，则不会以 `object` 作为基类

# 多态

...


# 类

**实例**

1. 使用面向对象开发，第一步是设计类
2. 使用 类名() 创建对象：
   - 1) 在内存中为对象 分配空间
   - 2) 调用初始化方法 `__init__` 为对象初始化
3. 对象创建后，内存中便有了一个对象，即类的实例

- 每一个对象都有自己独立的内存空间，保存各自不同的属性
- 多个对象的方法，在内存中只有一份，在调用方法时，需要把对象的引用传递到方法内部

**类是一个特殊的对象**

> Python 中 一切皆对象
>  - class AAA: 定义的类属于 类对象
>  - obj1 = AAA() 属于 实例对象

- 在程序运行时，类同样 会被加载到内存
- 在 Python 中，类是一个特殊的对象 -- 类对象
- 在程序运行时，类对象 在内存中 只有一份，使用 一个类 可以创建出 很多个对象实例
- 除了封装 实例 的 属性和方法 外，类对象还可以拥有自己的 属性和方法
  - 类属性
  - 类方法
- 通过 `类名.` 的方式可以 访问类的属性 或者 调用类的方法


**类属性和实例属性**

- 类属性 就是给 类对象 中定义的 属性，通常用来记录 与这个类相关 的特征
- 类属性 不会用于激烈 具体对象的特征

**属性的获取机制**

- 在 Python 中 属性的获取 存在一个 向上查找机制

**类方法**

- 类方法需要用 修饰器 `@classmethod` 来标识，告诉解释器这是一个类方法
- 类方法的第一个参数应该是 `cls`
  - 由 哪一个类 调用的方法，方法内的 `cls` 就是哪一个类的引用
  - 这个参数和 实例方法 的的第一个参数 `self` 类似
  - 提示：使用其他名称也可以，不过习惯上使用 `cls`
- 通过 `类名.` 调用 类方法，调用方法时，不需要传递 `cls` 参数
- 在方法内部
  -  可以通过 `cls.` 访问类的属性
  -  也可以通过 `cls.` 调用其它的类方法

```python
@classmethod
def 类方法名(cls):
   pass
```

**静态方法**

- 在开发时，如果需要在 类 中封装一个方法，这个方法：
   - 既不需要 访问 实例属性 或者调用 实例方法
   - 也不需要 访问 类属性 或者调用 类方法
- 这个时候，可以把这个方法封装成一个 静态方法

- 静态方法 需要用 修饰器 @staticmethod 来标识，告诉解释器这是一个静态方法
- 通过 `类名.` 调用 静态方法

```python
@staticmethod
def 静态方法名():
   pass
```

**小结**

1. 实例方法 -- 方法内部需要访问 实例属性
   - 实例方法 内部可以使用 `类名.` 访问类属性
2. 类方法 -- 方法内部只需要访问类属性
3. 静态方法 -- 方法内部，不需要访问 实例属性 和 类属性


# 单例

## 单例设计模式

- 设计模式
  - 设计模式 是前人工作的总结和提炼，通常，被人们广泛流传的设计模式都是针对 某一特定问题 的成熟的解决方案
  - 使用 设计模式 是为了可重用代码、让代码更容易被他人理解、保证代码可靠性

- 单例设计模式
  - 目的 -- 让 类 创建的对象，在系统中 只有 唯一的一个实例
  - 每一次执行 `类名()` 返回的对象，内存地址是相同的

**单例设计模式的应用场景**

- 音乐播放对象
- 回收站对象
- 打印机对象
- ……

## __new__ 方法

- 使用 `类名()` 创建对象时，Python 的解释器 首先 会调用 `__new__` 方法为对象 分配空间
- `__new__` 是一个由 `object` 基类提供的 内置的静态方法，主要作用有两个:
  - 1) 在内存中为对象 分配空间
  - 2) 返回对象的引用
- Python 的解释器获得对象的 引用 后，将引用作为 第一个参数，传递给 `__init__` 方法


- 重写 `__new__` 方法一定要 `return super().__new__(cls`
- 否则 Python 的解释器 得不到分配了空间的 对象引用，就不会调用对象的初始化方法
- 注意：`__new__` 是一个静态方法，在调用时需要 主动传递 `cls` 参数


## Python 中的单例

- 单例 -- 让 类 创建的对象，在系统中 只有 唯一的一个实例
  - 定义一个 类属性，初始值是 `None`，用于记录 单例对象 的引用
  - 重写 `__new__` 方法
  - 如果 类属性 `is None`，调用父类方法分配空间，并在类属性中记录结果
  - 返回 类属性 中记录的 对象引用

## 只执行一次初始化工作

- 在每次使用 `类名()` 创建对象时，Python 的解释器都会自动调用两个方法：
   - `__new__` 分配空间
   - `__init__` 对象初始化

- 需求

- 解决办法
  - 定义一个类属性 `init_flag` 标记是否 执行过初始化动作，初始值为 `False`
  - 在 `__init__` 方法中，判断 `init_flag`，如果为 `Flase` 就执行初始化动作
  - 然后将 `init_flag` 设置为 `True`
  - 这样，再次 自动 调用 `__init__` 方法时，初始化动作就不会再次执行


# 异常

## 异常的概念

- 程序在运行时，如果 Python 解释器 遇到一个错误，会停止程序的执行，并且提示一些错误信息，这就是 异常
- 程序停止执行并且提示错误信息这个动作，我们称之为：抛出（raise）异常

## 捕获异常

**简单的捕获异常语法**

- 在程序开发中，如果 对某些代码的执行不能确定是否正确，可以增加 `try（尝试）` 来捕获异常

```python
try:
   尝试执行的代码
except:
   出现错误的处理
```

- `try` 尝试，下方编写要尝试代码，不确定是否能够正确执行的代码
- `except` 如果不是，下方编写失败时需要执行的代码


## 错误类型捕获

- 在程序执行时，可能会遇到不同类型的异常，并且需要 针对不同类型的数据做出不同的响应，这个时候就需要捕获错误类型

```python
try:
   pass
except 错误类型1:
   pass
except (错误类型2, 错误类型3):
   pass
except Exception as reult:
   print(f"未知错误 {result}")

```

- 当 python 解释器抛出异常 时，最后一行错误信息的第一个单词就是错误类型

**捕获未知错误**

- 如果希望程序 无论出现任何错误，都不会因为 Python 解释器抛出异常而被终止，可以增加一个 except

```python
except Exception as result:
   pass
```


## 异常捕获完整语法

```python
try:
   pass
except erroType1:
   pass
except errorType2:
   pass
except Exception as result:
   pass
else:
   # 没有异常才会执行的代码
   pass
finally:
   # 无论是否有异常都会执行的代码
   pass
```

## 异常的传递

- 异常的传递 -- 当 函数/方法 执行出现异常，会将异常传递给 函数/方法 的 调用一方
- 如果 传递到主程序，仍然没有异常处理，程序才会被终止


## 抛出 raise 异常

**应用场景**

- Python 中提供了一个 Eception 异常类

- 在开发中，可以根据 应用程序 特有的业务需求 主动抛出异常
  - 创建一个 `Exception` 对象
  - 使用 `raise` 关键字抛出异常



# 模块

- 每一个以扩展名 py 结尾的 Python 源代码文件都是一个模块
- 模块名同样也是一个 标识符
- 在模块中定义的 全局变量、函数、类 都是模块能够提供给外界直接使用的工具

`import` 导入
`as` 使用别名
`from import`

**模块的搜索顺序**

Python 的解释器在 导入模块 时：
1. 搜索 当前目录 指定模块名的文件，如果有就直接导入
2. 如果没有，再搜索系统目录

> 在开发时，给文件起名，不要和 系统 的模块文件 重名

Python 中的每一个模块都有一个内置属性 `__file__` 可以查看模块 的 完整路径


**开发原则 -- 每一个文件都应该时可以被导入的**

- 一个 独立的 Python 文件 就是一个模块
- 在导入文件时，文件中 所有没有任何缩进的代码 都会被执行一遍

## `__name__`属性

- `__name__` 属性可以做到，测试模块的代码只在测试情况下被执行，而在 被导入时不会执行

- `__name__` 是 Python 中的一个内置属性，记录着一个字符串
- 如果 是被其它文件导入的， `__name__` 就是 模块名
- 如果 是当前执行的程序 `__name__` 是 `__main__`

## 包（Package）

**概念**

- 包 是一个 包含多个模块 的 特殊目录
- 目录下有一个 特殊的文件 `__init__.py`
- 包名的 命名方式 和 变量名一致，小写字符 + `_`

- 要在外部使用 `hm_message` 中的模块，需要在 `__init__.py` 中指定 对外界提供的模块列表

**好处**

- 使用 `import 包名` 可以一次性导入 包 中所有的模块



# 文件

**文件的存储方式**

- 文本文件
  - 可以使用 文本编辑软件 查看
  - 本质上还是二进制文件
  - 例如：python 的源程序
- 二进制文件
  - 保存的内容不是给人直接阅读的，而是 提供给其它软件使用的
  - 例如：图片文件、音频文件、视频文件 等等
  - 二进制文件不能使用 文本编辑软件 查看

## 文件的基本操作

**操作文件的套路**

1. 打开文件
2. 读写文件
   - 读 将文件内容读入内存
   - 写 将内存内容写入文件
3. 关闭文件

**操作文件的函数/方法**

函数/方法|说明
-|-
open|打开文件，并且返回文件操作对象
read|将文件内容读取到内存
write|将指定内容写入文件
close|关闭文件

- `open` 函数负责打开文件，并且返回文件操作对象
- `read`/`write`/`close` 三个方法都需要通过 文件对象 来调用

## read 方法 -- 读取文件

- open 函数的第一个参数是要打开的文件名
  - 如果文件存在，返回 文件操作对象
  - 如果文件不存在，会 抛出异常
- read 方法可以一次性 读入 并返回文件的 所有内容
- close 方法负责 关闭文件
  - 如果忘记关闭文件，会造成系统资源消耗，而且会影响到后续对文件的访问、
- 注意：方法执行后，会把 文件指针 移动到 文件的末尾

## 文件指针

- 文件指针 标记 从哪个位置开始读取数据
- 第一次打开 文件时，通常 文件指针会执行文件的开始位置
- 当执行了 read 方法后，文件指针会移动到 读取内容的末尾
  - 默认情况下会移动到文件末尾

## 打开文件的方式

- open 函数默认以 只读方式 打开文件，并且返回文件对象

语法如下：
`f = open("文件名", "访问方式")`

访问方式|说明
-|-
r|以只读方式打开文件。文件的指针将会放在文件的开头，这是默认模式。如果文件不存在，抛出异常
w|以只写方式打开文件。如果文件存在将被覆盖。如果文件不存在，创建新文件
a|以追加方式打开文件。如果该文件已存在，文件指针将会放在文件的结尾。如果文件不存在，创建新文件进行写入
r+|以读写的方式打开文件。文件的指针将会放在文件的开头。如果文件不存在，抛出异常
w+|以读写的方式打开文件。如果文件存在会被覆盖。如果文件不存在，创建新文件
a+|以读写方式打开文件，如果文件已存在，文件指针将会放在文件的结尾。如果文件不存在，创建新文件进行写入

## 执行读取文件内容

- `readline` 方法可以一次读取一行内容
- 方法执行后，会把文件指针移到写一行，准备再次读取

## 文件/目录的常用管理操作

- 在 终端/文件浏览器 中可以执行常规的 文件/目录 管理操作，例如：
  - 创建、重命名、删除、改变路径、查看目录内容
- 在 Python 中，如果希望通过程序实现上述功能，需要导入 `os` 模块


**文件操作**
方法名|说明|示例
-|-|-
rename|重命名文件|os.rename(源文件名,  目标文件名)
remove|删除文件|os.remove(文件名)


**目录操作**

方法名|说明|示例
—|-|-
listdir|目录列表|os.listdir(目录名)
mkdir|创建列表|os.mkdir(目录名)
mkdir|创建列表|os.mkdir(目录名)
rmdir|删除目录|os.rmdir(目录名)
getcwd|获取当前目录|os.getcwd()
chdir|修改工作目录|os.chdir(目标目录)
path.isdir|判断是否时文件|os.path.isdir(文件路径)

- 文件或目录都支持 相对路径 和 绝对路径


## 文件文本的编码格式

- 文本文件存储的内容是基于字符编码的文件

> Python 2.x 默认使用 ASCII 编码
> Python 3.x 默认使用 UTF-8 编码



# eval 函数

`eval()` 函数 -- 将字符串 当成 有效的表达式 来求值 并 返回计算结果

**不要滥用 eval**

> 在开发时千万不要用 `eval` 直接转换 `input` 的结果

`__import__('os').system('ls')`

- 等价代码

```python
import os
os.system("终端命令")
```




# 另学补充（from 《Python语言 程序设计》）

## 位运算符

## 成员运算符 与 身份运算符

## complex 类型

## math模块

## random模块

## 集合

**集合运算**

## 文件与目录操作

### 文件操作

### 目录操作

**os模块**

## global 与 nonlocal 关键字

## 高阶函数、递归函数 与 匿名函数

**高阶函数**

- 如果函数接收的参数中包含函数名或函数返回中包含函数名，这样的函数就是高阶函数

**匿名函数**

`lambda arg1, arg2, ..., argn:expression`

1. 参数可以有多个，参数之间用 `,` 分隔
2. 匿名函数不管逻辑多复杂，只能写一行，且逻辑执行结束后的结果就是返回值
3. 返回值和正常的函数一样可以是任意数据类型

- 匿名函数的调用方法：直接赋值给一个变量，然后再像一般函数一样调用

```python
f = lambda a,b,c:a+b+c

# 关键字 lambda 表示匿名函数，冒号之前的 a, b, c 为这个函数的参数，冒号之后的表达式的结果就是返回值

print(f(1, 2, 3))
```

- 在匿名函数中可以使用 默认值传值
- 在匿名函数中可以使用 无名参数
- 在匿名函数中也可以使用 有名参数
- 在匿名函数中可以直接在函数后传递参数


## 装饰器

装饰器是函数式编程的重要概念。装饰器就是在不改变函数功能的前提下对函数的功能进行扩充的一种方法，因此可以把装饰器理解为一个包装函数的函数

### 闭包

**闭包的定义**

闭包是指如果在一个内部函数中，对在外层作用域（但不是在全局作用域）的变量进行引用，内部函数就会被认为是闭包

```python
def outer(n):
   sum = n
   def inner():
      return sum + 1
   return inner


myFunc = outer(10)
print(myFunc())
myAnotherFunc = outer(20)
print(myAnotherFunc())
```

在这段程序中,函数 inner 是函数 outer 的内嵌函数,并且是 outer 函数的返回值。在上述嵌套定义的函数中，内嵌函数 inner 中引用到外层函数中的局部变量 x。当用不同的参数调用 outer 函数得到的函数得到的返回函数 myFunc 与 myAnotherFunc，得到的结果是隔离的，即每次调用 outer 函数后都将生成并保存一个新的局部变量 sum。而这里的 outer函数返回的就是闭包。

按照命令式语言的规则，outer 函数只是返回了内嵌函数 inner 的地址，在执行 inner 函数时会由于在其作用域内找不到 sum 变量而出错。而在函数式语言中，当内嵌函数体内引用到体外的变量时，将会把定义是涉及的引用环境和函数体打包成一个整体（闭包）返回。如果引入引用环境来定义闭包：引用环境是指在程序执行中的某点所有处于活跃状态的约束（一个变量的名字和其所代表的对象之间的联系）所组成的集合。闭包的使用与正常的函数调用没有区别

由于闭包把函数和运行时的引用环境打包成为一个新的整体，所以就解决了函数编程中的嵌套所引发的问题。与函数不同的是，闭包在运行时可以产生不同的实例


**闭包的作用**

闭包主要是在函数式开发过程中使用，闭包主要用于保持当前的运行环境。例如：如果编程者希望函数的每次执行结果都是基于函数上次运行的结果，可以通过闭包来实现


## 装饰器

> 变量搜索优先级 LEGB 局部作用域->外层作用域->全局作用域->内置作用域

**语法糖@**

为避免在定义函数时再一次给函数赋值而引入的语法糖


## 生成器与迭代器

### 生成器

**什么是生成器**

生成器（generator）是一个特殊的程序，可以用来控制循环的迭代行为，在 Python 中，生成器是迭代器的一种，使用 yield 返回值的函数，每次调用 yield 会暂停，而可以使用 next()函数 和 send()函数 恢复生成器

[什么是yield、next()、send()](https://blog.csdn.net/mieleizhi0522/article/details/82142856/)

[理解StopIteration的异常](https://blog.csdn.net/shitoucoming/article/details/108714288)

[将StopIteraion用来作为迭代器的输出挺迟/next()](https://blog.csdn.net/csdnhuizhu/article/details/107268520)

生成器类似于返回值为数组的一个函数，这个函数可以接收参数，可以被调用，但不同于一般的函数只会调用一次性返回包括了所有数值的数组，生成器一次只能产生一个值，这样消耗的内存数量将大大减小。而且允许调用函数可以很快地处理前几个返回值。因此生成器看起来是一个函数器，但是表现得却像是一个迭代器

**生成器的创建**

要创建一个 generator 主要有两种方法

1. 把一个列表生成器的 `[]` 改为 `()`

`generator_list = (x*x for i in range(0, 10))`

生成器保存的是算法，每次调用 `next(generator_list)` 时计算出下一个元素的值，一直计算出最后一个元素的值，当生成器已没有元素能生成时，就会抛出 StopInteration 的错误

为防止报错，比较稳妥的方法是使用 for 循环进行迭代

```python
generator_ex = (x*x for x in range(10))
for i in generator_ex:
   print(i)
```

2. 使用 yield 方法生成

生成器跟普通函数不同的是，当一个生成器函数被调用时，它返回一个生成器对象，而不用执行该函数。在调用生成器的过程中，每次遇到 yield 时函数会暂停并保存当前所有的运行信息，返回 yield 的值，并在下一次执行 next() 时从当前位置继续执行

使用 for 循环调用生成器时取不到生成器的返回值，此时可以通过捕获 StopInteration 的错误，并在 StopInteration 的 value 中取得返回值

```python
def fib(max):
    n, before, after = 0, 0, 1
    while n < max:
        yield after
        before, after = after, before + after
        n += 1
    return 'done'


g = fib(10)
while True:
    try:
        x = next(g)
        print('g:', x)
    except StopIteration as e:
        print('Generator return value:', e.value)
        break
```

**生成器的send函数**

`send()`函数与`next()`类似，不同的是 send 函数可以向生成器传递参数

在使用 send 函数时，不能将一个非 None 的值传给初始的生成器，即在调用 send 前，生成器内部应该执行道 yield 所在的语句并暂停。在调用带非空参数的 send 函数之前，应该使用 next(generator) 或者 send(None), 使得生成器执行到 yield 语句并暂停。


**总结**

生成器随着时间的推移生成了一个数值队列。一般的函数在执行完毕之后会返回一个值然后退出，但是生成器会自动挂起，然后重新继续执行，它会利用 yield 关键字挂起函数，给调用者返回一个值，同时保留了当前的状态，可以使函数继续执行，生成器和迭代协议是密切相关的，可迭代的对象都有一个 next 方法，这个方法要么返回迭代的下一项，要么引起异常结束迭代。具有 yield 关键字的函数都是生成器，yield 可以理解为 return 不同的是 return 返回后，函数会释放，而生成器则不会。在直接调用 next 方法或用 for 语句进行下一次迭代时，生成器会从 yield 下一句开始执行，直至遇到下一个 yield


### 迭代器

迭代是访问集合元素的一种方式。迭代器（iterator）是一个可以记住遍历位置的对象。迭代器对象是实现了 iter 和 next 两个方法的对象：iter 用于创建迭代对象，next 用于获得下一个迭代元素。在 Python 中，访问迭代器对象时只能从第一个元素开始访问，直到所有元素被访问完结束。string、list 和 tuple 对象可用于创建迭代器。

迭代器的特征是从集合的第一个元素开始访问对象，直到所有元素被访问完结束，访问对象元素时只能从前往后访问。使用迭代器的优点是不要求事先准备好整个迭代过程中的所有元素。迭代器仅在迭代到某个元素时才计算该元素，而在这之前或之后元素可以不存在或者被摧毁。因此迭代器适合遍历一些数量巨大甚至无限的序列


### 可迭代对象与迭代器判断

可直接作用于 for 循环的数据类型有两类：一类是数据类型，另一类是生成器。在 Python 中，可以直接作用于 for 循环的对象统称为可迭代对象（Iterable）。判断一个对象是否为可迭代对象可以使用 `isinstance()` 函数

```python
from collections.abc import Iterable
isinstance([], Iterable)
```

生成器都是迭代器对象，但 list、dict、str 虽然是可迭代对象，却不是迭代器对象。把 list、dict、str 等可迭代对象迭代器对象可以使用 iter() 函数
